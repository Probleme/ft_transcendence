"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-stacked-center-carousel@1.0.14_react-dom@18.3.1_react@18.3.1__react@18.3.1";
exports.ids = ["vendor-chunks/react-stacked-center-carousel@1.0.14_react-dom@18.3.1_react@18.3.1__react@18.3.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/react-stacked-center-carousel@1.0.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-stacked-center-carousel/dist/index.modern.js":
/*!*****************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-stacked-center-carousel@1.0.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-stacked-center-carousel/dist/index.modern.js ***!
  \*****************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResponsiveContainer: () => (/* binding */ ResponsiveContainer),\n/* harmony export */   StackedCarousel: () => (/* binding */ StackedCarousel)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.2.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_resize_detector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-resize-detector */ \"(ssr)/./node_modules/.pnpm/react-resize-detector@7.1.2_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-resize-detector/build/index.esm.js\");\n\n\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar StackedCarousel = /*#__PURE__*/function (_React$PureComponent) {\n  _inheritsLoose(StackedCarousel, _React$PureComponent);\n\n  function StackedCarousel(props) {\n    var _this;\n\n    _this = _React$PureComponent.call(this, props) || this;\n\n    _this.validateProps = function () {\n      var _this$props = _this.props,\n          swipeSpeed = _this$props.swipeSpeed,\n          currentVisibleSlide = _this$props.currentVisibleSlide,\n          maxVisibleSlide = _this$props.maxVisibleSlide,\n          fadeDistance = _this$props.fadeDistance,\n          customScales = _this$props.customScales,\n          data = _this$props.data;\n\n      if (data.length < (maxVisibleSlide + 1) / 2) {\n        throw Error('you must have more than (maxVisibleSlide + 1) / 2 data item');\n      }\n\n      if (currentVisibleSlide && currentVisibleSlide % 2 !== 1 || maxVisibleSlide % 2 !== 1) {\n        throw Error('currentVisibleSlide or maxVisibleSlide must be an odd number');\n      }\n\n      if (currentVisibleSlide && currentVisibleSlide > maxVisibleSlide) {\n        throw Error('currentVisibleSlide must be smaller than maxVisibleSlide');\n      }\n\n      if (fadeDistance !== undefined) {\n        if (fadeDistance > 1 || fadeDistance < 0) {\n          throw Error('fadeDistance is a percentage value in the range of 0 - 1');\n        }\n      }\n\n      if (customScales && customScales.length !== (maxVisibleSlide + 3) / 2) {\n        throw Error('customScales must have lengh (maxVisibleSlide + 3) / 2');\n      }\n\n      if (swipeSpeed && (swipeSpeed > 0.99 || swipeSpeed < 0.01)) {\n        throw Error('swipeSpeed must have a value between 0.01 and 0.99');\n      }\n    };\n\n    _this.initializeProperties = function (constructor) {\n      if (constructor === void 0) {\n        constructor = false;\n      }\n\n      _this.validateProps();\n\n      var _this$props2 = _this.props,\n          carouselWidth = _this$props2.carouselWidth,\n          slideWidth = _this$props2.slideWidth,\n          currentVisibleDisplaySlide = _this$props2.currentVisibleSlide,\n          maxVisibleSlide = _this$props2.maxVisibleSlide;\n      var currentVisibleSlides = currentVisibleDisplaySlide || maxVisibleSlide;\n      var visibleSlidePerSide = (currentVisibleSlides - 1) / 2;\n      var slidePerSide = Math.max(visibleSlidePerSide + 1, 1);\n      var totalRenderCount = maxVisibleSlide + 2;\n      var renderedSlidePerSide = (maxVisibleSlide + 1) / 2;\n\n      var _this$calculateScaleA = _this.calculateScaleAndOffsets(slidePerSide),\n          offsets = _this$calculateScaleA.offsets,\n          scaledOffsets = _this$calculateScaleA.scaledOffsets,\n          scales = _this$calculateScaleA.scales;\n\n      var newRenderedSlides = constructor ? Array(totalRenderCount).fill(null) : _this.state.renderedSlides.filter(function (_ref) {\n        var slideIndex = _ref.slideIndex,\n            dataIndex = _ref.dataIndex;\n        return dataIndex === -1 || Math.abs(slideIndex) <= _this.slidePerSide;\n      });\n      var slideInfoMap = {};\n      var newCenterSlideRelativeIndex = constructor ? (totalRenderCount - 1) / 2 : newRenderedSlides.findIndex(function (_ref2) {\n        var slideIndex = _ref2.slideIndex;\n        return slideIndex === 0;\n      });\n      var newCenterDataIndex = constructor ? 0 : newRenderedSlides[newCenterSlideRelativeIndex].dataIndex;\n      var filledWidth = 0;\n      var centerPosition = carouselWidth / 2 - slideWidth / 2;\n\n      var _loop = function _loop(absIndex) {\n        var offset = offsets[absIndex];\n        var slideScale = scales[absIndex];\n        var currentOffSet = filledWidth + offset;\n        [-absIndex, absIndex].forEach(function (slideIndex) {\n          var relativeIndex = newCenterSlideRelativeIndex + slideIndex;\n          var position = slideIndex >= 0 ? currentOffSet : -currentOffSet;\n          var opacity = absIndex === slidePerSide ? 0 : 1;\n\n          var dataIndex = _this.modDataRange(newCenterDataIndex + slideIndex);\n\n          newRenderedSlides[relativeIndex] = {\n            dataIndex: dataIndex,\n            scale: slideScale,\n            position: position,\n            slideIndex: slideIndex,\n            opacity: opacity,\n            zIndex: renderedSlidePerSide - Math.abs(slideIndex),\n            key: constructor ? slideIndex : newRenderedSlides[relativeIndex].key\n          };\n          slideInfoMap[slideIndex] = {\n            position: position,\n            scale: slideScale,\n            opacity: opacity\n          };\n        });\n        if (absIndex !== 0) filledWidth += scaledOffsets[absIndex];\n      };\n\n      for (var absIndex = 0; absIndex <= slidePerSide; absIndex++) {\n        _loop(absIndex);\n      }\n\n      for (var i = -slidePerSide; i <= slidePerSide; i++) {\n        slideInfoMap[i].maxTransformDistance = {};\n        slideInfoMap[i].maxTransformScale = {};\n        slideInfoMap[i].maxTransformOpacity = {\n          left: i === -slidePerSide + 1 || i === slidePerSide ? 1 : 0,\n          right: i === -slidePerSide || i === slidePerSide - 1 ? 1 : 0\n        };\n        slideInfoMap[i].slideIndex = i;\n\n        if (i === -slidePerSide) {\n          slideInfoMap[i].maxTransformDistance.left = 0;\n          slideInfoMap[i].maxTransformScale.left = 0;\n        } else {\n          slideInfoMap[i].maxTransformDistance.left = slideInfoMap[i].position - slideInfoMap[i - 1].position;\n          slideInfoMap[i].maxTransformScale.left = Math.abs(slideInfoMap[i].scale - slideInfoMap[i - 1].scale);\n        }\n\n        if (i === slidePerSide) {\n          slideInfoMap[i].maxTransformDistance.right = 0;\n          slideInfoMap[i].maxTransformScale.right = 0;\n        } else {\n          slideInfoMap[i].maxTransformDistance.right = slideInfoMap[i + 1].position - slideInfoMap[i].position;\n          slideInfoMap[i].maxTransformScale.right = Math.abs(slideInfoMap[i + 1].scale - slideInfoMap[i].scale);\n        }\n      }\n\n      if (maxVisibleSlide > currentVisibleSlides) {\n        var maxRenderedSlidePerSide = (maxVisibleSlide + 1) / 2;\n        var currentSlidePerSide = slidePerSide;\n\n        for (var _i = currentSlidePerSide + 1; _i <= maxRenderedSlidePerSide; _i++) {\n          for (var direct = 1; direct >= 0; direct--) {\n            var insertIndex = newCenterSlideRelativeIndex + (direct === 1 ? _i : -_i);\n            var prevIndex = insertIndex + (direct === 1 ? -1 : 1);\n            var slideIndex = direct === 1 ? _i : -_i;\n            var scalePositionIndex = constructor ? prevIndex : insertIndex;\n            newRenderedSlides[insertIndex] = {\n              scale: newRenderedSlides[scalePositionIndex].scale,\n              position: newRenderedSlides[scalePositionIndex].position,\n              key: constructor ? -slideIndex : newRenderedSlides[insertIndex].key,\n              dataIndex: -1,\n              slideIndex: slideIndex,\n              opacity: 0,\n              zIndex: 0\n            };\n          }\n        }\n      }\n\n      var sortedSlideInfo = Object.values(slideInfoMap);\n      sortedSlideInfo.sort(function (slide1, slide2) {\n        return slide1.position - slide2.position;\n      });\n      return {\n        renderedSlides: newRenderedSlides,\n        centerSlideRelativeIndex: newCenterSlideRelativeIndex,\n        slideInfoMap: slideInfoMap,\n        slidePerSide: slidePerSide,\n        newRenderedSlides: newRenderedSlides,\n        sortedSlideInfo: sortedSlideInfo,\n        centerPosition: centerPosition,\n        renderedSlidePerSide: renderedSlidePerSide\n      };\n    };\n\n    _this.calculateScaleAndOffsets = function (slidePerSide) {\n      var _this$props3 = _this.props,\n          carouselWidth = _this$props3.carouselWidth,\n          slideWidth = _this$props3.slideWidth,\n          customScales = _this$props3.customScales,\n          fadeDistance = _this$props3.fadeDistance;\n      var availableSpace = carouselWidth / 2 - slideWidth / 2;\n      var scales = [1];\n      var scaledSlideWidths = [slideWidth];\n\n      for (var slide = 1; slide <= slidePerSide; slide++) {\n        var scale = customScales ? customScales[slide] : Math.pow(StackedCarousel.defaultScaleFactor, slide);\n        scales.push(scale);\n        scaledSlideWidths.push(slideWidth * scale);\n      }\n\n      var includedSlideWidths = scaledSlideWidths.slice(1);\n      var fillingSpace = availableSpace;\n\n      if (fadeDistance !== undefined) {\n        includedSlideWidths = scaledSlideWidths.slice(1, slidePerSide);\n        fillingSpace = availableSpace * (1 - fadeDistance);\n      }\n\n      var totalSlideWidth = includedSlideWidths.reduce(function (a, b) {\n        return a + b;\n      }, 0);\n      var offSetPercentage = totalSlideWidth ? fillingSpace / totalSlideWidth : 0;\n      var scaledOffsets = [0];\n      var offsets = [0];\n\n      for (var _slide = 1; _slide <= slidePerSide; _slide++) {\n        var isCustomFade = fadeDistance !== undefined && _slide === slidePerSide;\n        var _scale = scales[_slide];\n        scaledOffsets[_slide] = isCustomFade ? fadeDistance * availableSpace : slideWidth * _scale * offSetPercentage;\n        offsets[_slide] = scaledOffsets[_slide] + slideWidth * ((1 - _scale) / 2);\n      }\n\n      return {\n        offsets: offsets,\n        scaledOffsets: scaledOffsets,\n        scales: scales\n      };\n    };\n\n    _this.getZIndex = function (slideIndex) {\n      return _this.renderedSlidePerSide - Math.abs(slideIndex);\n    };\n\n    _this.updateHeight = function () {\n      var height = _this.props.height;\n      if (height) return;\n\n      var _this$getSlideDOMInfo = _this.getSlideDOMInfo(0),\n          slideDOM = _this$getSlideDOMInfo.slideDOM;\n\n      var parsedHeight = parseInt(window.getComputedStyle(slideDOM).height);\n\n      if (parsedHeight !== _this.height) {\n        _this.height = parsedHeight;\n\n        _this.forceUpdate();\n      }\n    };\n\n    _this.modDataRange = function (n) {\n      var data = _this.props.data;\n      var m = data.length;\n      return (n % m + m) % m;\n    };\n\n    _this.debouncedClearInvisibleSlide = function () {\n      var transitionTime = _this.props.transitionTime;\n      clearTimeout(_this.clearSlideTimeout);\n      _this.clearSlideTimeout = setTimeout(_this.clearUselessSlide, transitionTime !== undefined ? transitionTime : StackedCarousel.defaultTransitionTime);\n    };\n\n    _this.clearUselessSlide = function () {\n      _this.addedSlide = 0;\n      var renderedSlides = _this.state.renderedSlides;\n      var newRenderedSlides = renderedSlides.filter(function (_ref3) {\n        var slideIndex = _ref3.slideIndex,\n            dataIndex = _ref3.dataIndex;\n        var absoluteSlideIndex = Math.abs(slideIndex);\n\n        if (absoluteSlideIndex <= _this.slidePerSide || dataIndex === -1) {\n          return true;\n        }\n\n        return false;\n      });\n\n      _this.setState({\n        renderedSlides: newRenderedSlides\n      });\n    };\n\n    _this.safeGetSlideInfo = function (slideIndex) {\n      var positionIndex = slideIndex;\n\n      if (positionIndex > _this.slidePerSide) {\n        positionIndex = _this.slidePerSide;\n      } else if (positionIndex < -_this.slidePerSide) {\n        positionIndex = -_this.slidePerSide;\n      }\n\n      return _this.slideInfoMap[positionIndex];\n    };\n\n    _this.getInsertionInfo = function (steps) {\n      var newAddedSlideIndex = steps > 0 ? _this.slidePerSide - steps + 1 : -_this.slidePerSide - steps - 1;\n      var targetSlideIndex = steps > 0 ? _this.slidePerSide : -_this.slidePerSide;\n\n      var requireMoreSlide = function requireMoreSlide(current, target) {\n        return steps > 0 ? current <= target : current >= target;\n      };\n\n      var updateCount = steps > 0 ? 1 : -1;\n      return {\n        newAddedSlideIndex: newAddedSlideIndex,\n        targetSlideIndex: targetSlideIndex,\n        requireMoreSlide: requireMoreSlide,\n        updateCount: updateCount\n      };\n    };\n\n    _this.moveCarousel = function (steps, disableSwipeRightState) {\n      if (disableSwipeRightState === void 0) {\n        disableSwipeRightState = false;\n      }\n\n      var renderedSlides = _this.state.renderedSlides;\n      var onActiveSlideChange = _this.props.onActiveSlideChange;\n      var newCenterDataIndex = 0;\n      var newSlides = renderedSlides.map(function (oldSlide) {\n        var slideIndex = oldSlide.slideIndex,\n            dataIndex = oldSlide.dataIndex;\n        if (dataIndex === -1) return oldSlide;\n        if (slideIndex === 0) newCenterDataIndex = _this.modDataRange(dataIndex + steps);\n        var newSlideIndex = slideIndex + -steps;\n\n        var slideInfo = _this.safeGetSlideInfo(newSlideIndex);\n\n        return _extends({}, oldSlide, {\n          slideIndex: newSlideIndex,\n          position: slideInfo.position,\n          scale: slideInfo.scale,\n          opacity: slideInfo.opacity,\n          zIndex: _this.getZIndex(newSlideIndex)\n        });\n      });\n\n      if (steps !== 0) {\n        (function () {\n          var maxSlideIndex = steps > 0 ? _this.slidePerSide : -_this.slidePerSide;\n          _this.addedSlide += Math.abs(steps);\n\n          var insertionInfo = _this.getInsertionInfo(steps);\n\n          var newAddedSlideIndex = insertionInfo.newAddedSlideIndex;\n          var requireMoreSlide = insertionInfo.requireMoreSlide,\n              updateCount = insertionInfo.updateCount,\n              targetSlideIndex = insertionInfo.targetSlideIndex;\n\n          while (requireMoreSlide(newAddedSlideIndex, targetSlideIndex)) {\n            var slideAlreadyExist = newSlides.find(function (_ref4) {\n              var slideIndex = _ref4.slideIndex;\n              return slideIndex === newAddedSlideIndex;\n            });\n\n            if (!slideAlreadyExist) {\n              var insertPosition = newSlides.findIndex(function (_ref5) {\n                var slideIndex = _ref5.slideIndex,\n                    dataIndex = _ref5.dataIndex;\n                return slideIndex === newAddedSlideIndex - updateCount && dataIndex !== -1;\n              });\n              var _this$slideInfoMap$ma = _this.slideInfoMap[maxSlideIndex],\n                  scale = _this$slideInfoMap$ma.scale,\n                  position = _this$slideInfoMap$ma.position;\n\n              var insertDataIndex = _this.modDataRange(newSlides[insertPosition].dataIndex + updateCount);\n\n              _this.keyCount += 1;\n\n              var zIndex = _this.getZIndex(newAddedSlideIndex);\n\n              var insertSlide = {\n                scale: scale,\n                position: position,\n                opacity: 0,\n                zIndex: zIndex - _this.addedSlide,\n                slideIndex: newAddedSlideIndex,\n                dataIndex: insertDataIndex,\n                key: _this.keyCount\n              };\n              newSlides.splice(steps > 0 ? insertPosition + 1 : insertPosition, 0, insertSlide);\n            }\n\n            newAddedSlideIndex += updateCount;\n          }\n        })();\n      }\n\n      if (steps !== 0 && onActiveSlideChange) {\n        onActiveSlideChange(newCenterDataIndex);\n      }\n\n      _this.setState(function () {\n        return {\n          swipeStarted: false,\n          renderedSlides: newSlides,\n          swipRight: disableSwipeRightState ? false : steps < 0 ? true : false\n        };\n      }, function () {\n        setTimeout(function () {\n          _this.resetSlides();\n        }, 0);\n      });\n    };\n\n    _this.getSlideDOMInfo = function (slideIndex) {\n      var slideWidth = _this.props.slideWidth;\n      var listRef = _this.listRef.current;\n      var slideDOM = listRef.getElementsByClassName(\"react-stacked-center-carousel-slide-\" + slideIndex)[0];\n      var slideRect = slideDOM.getBoundingClientRect();\n\n      var _listRef$getBoundingC = listRef.getBoundingClientRect(),\n          carouselLeft = _listRef$getBoundingC.left;\n\n      var scale = slideRect.width / slideWidth;\n      var additionalOffset = slideWidth * 0.5 * (1 - scale);\n      var slideOffsetLeft = slideRect.left - carouselLeft - additionalOffset;\n      var slideCenterOffset = slideOffsetLeft - _this.centerPosition;\n      return {\n        scale: scale,\n        slideDOM: slideDOM,\n        slideCenterOffset: slideCenterOffset\n      };\n    };\n\n    _this.getSlideScaleAndOpacity = function (centerOffset) {\n      var targetSlide = _this.sortedSlideInfo.find(function (_ref6) {\n        var position = _ref6.position;\n        return Math.ceil(position) >= centerOffset;\n      }) || _this.sortedSlideInfo[_this.sortedSlideInfo.length - 1];\n\n      var position = targetSlide.position,\n          slideIndex = targetSlide.slideIndex,\n          scale = targetSlide.scale,\n          maxTransformDistance = targetSlide.maxTransformDistance,\n          maxTransformScale = targetSlide.maxTransformScale,\n          maxTransformOpacity = targetSlide.maxTransformOpacity,\n          opacity = targetSlide.opacity;\n      var offset = Math.ceil(position) - centerOffset;\n      var offsetPercentage = maxTransformDistance.left === 0 ? 0 : offset / maxTransformDistance.left * (slideIndex <= 0 ? -1 : 1);\n      return {\n        scale: scale + maxTransformScale.left * offsetPercentage,\n        opacity: opacity + maxTransformOpacity.left * offsetPercentage\n      };\n    };\n\n    _this.centerOffset = function (slideIndex) {\n      var _this$getSlideDOMInfo2 = _this.getSlideDOMInfo(slideIndex),\n          slideCenterOffset = _this$getSlideDOMInfo2.slideCenterOffset;\n\n      return Math.abs(_this.slideInfoMap[0].position - slideCenterOffset);\n    };\n\n    _this.onSwipeStart = function (e) {\n      var _this$props4 = _this.props,\n          onActiveSlideChange = _this$props4.onActiveSlideChange,\n          disableSwipe = _this$props4.disableSwipe;\n      if (disableSwipe) return;\n\n      var initalSwipeX = _this.getSwipeX(e);\n\n      var renderedSlides = _this.state.renderedSlides;\n      clearTimeout(_this.clearSlideTimeout);\n      var shiftDirection = 0;\n      var centerDataIndex = 0;\n      if (_this.centerOffset(-1) < _this.centerOffset(0)) shiftDirection = 1;else if (_this.centerOffset(1) < _this.centerOffset(0)) shiftDirection = -1;\n      var newRenderedSlides = [];\n      var swipePositionInfo = [];\n\n      for (var _iterator = _createForOfIteratorHelperLoose(renderedSlides), _step; !(_step = _iterator()).done;) {\n        var slide = _step.value;\n        var slideIndex = slide.slideIndex,\n            dataIndex = slide.dataIndex;\n\n        if (dataIndex === -1) {\n          newRenderedSlides.push(slide);\n          swipePositionInfo.push({\n            slideIndex: slideIndex,\n            maxLeft: 0,\n            maxRight: 0\n          });\n          continue;\n        }\n\n        var newSlideIndex = slideIndex + shiftDirection;\n        if (Math.abs(newSlideIndex) > _this.slidePerSide) continue;\n        if (newSlideIndex === 0) centerDataIndex = dataIndex;\n\n        var _this$getSlideDOMInfo3 = _this.getSlideDOMInfo(slideIndex),\n            slideCenterOffset = _this$getSlideDOMInfo3.slideCenterOffset,\n            scale = _this$getSlideDOMInfo3.scale;\n\n        var _this$getSlideScaleAn = _this.getSlideScaleAndOpacity(slideCenterOffset),\n            opacity = _this$getSlideScaleAn.opacity;\n\n        var _this$safeGetSlideInf = _this.safeGetSlideInfo(newSlideIndex),\n            maxTransformDistance = _this$safeGetSlideInf.maxTransformDistance,\n            position = _this$safeGetSlideInf.position;\n\n        swipePositionInfo.push({\n          slideIndex: newSlideIndex,\n          maxLeft: slideCenterOffset - position + maxTransformDistance.left,\n          maxRight: position + maxTransformDistance.right - slideCenterOffset\n        });\n        newRenderedSlides.push(_extends({}, slide, {\n          scale: scale,\n          opacity: opacity,\n          position: slideCenterOffset,\n          slideIndex: newSlideIndex,\n          zIndex: _this.getZIndex(newSlideIndex)\n        }));\n      }\n\n      if (onActiveSlideChange && shiftDirection !== 0) {\n        onActiveSlideChange(centerDataIndex);\n      }\n\n      _this.setState({\n        swipeStarted: true,\n        initalSwipeX: initalSwipeX,\n        renderedSlides: newRenderedSlides,\n        prevRenderedSlides: [].concat(newRenderedSlides),\n        swipePositionInfo: swipePositionInfo\n      });\n    };\n\n    _this.onSwipe = function (e) {\n      var swipeStarted = _this.state.swipeStarted;\n\n      if (!swipeStarted) {\n        return;\n      }\n\n      var _this$state = _this.state,\n          initalSwipeX = _this$state.initalSwipeX,\n          prevRenderedSlides = _this$state.prevRenderedSlides,\n          swipePositionInfo = _this$state.swipePositionInfo;\n      var slideWidth = _this.props.slideWidth;\n      var tempShift = false;\n\n      var currentSwipeX = _this.getSwipeX(e);\n\n      var swipeDistance = initalSwipeX - currentSwipeX;\n      var delta = Math.abs(swipeDistance);\n      var swipeLeft = swipeDistance > 0;\n      var transformFactor = 10 / slideWidth * delta;\n      var transformPercentage = 1 - Math.pow(1 - (_this.props.swipeSpeed || 0.5), transformFactor);\n      var newRenderedSlides = prevRenderedSlides.map(function (slide, index) {\n        var position = slide.position,\n            slideIndex = slide.slideIndex,\n            dataIndex = slide.dataIndex;\n        if (dataIndex === -1) return slide;\n        var maxDeltaX = swipePositionInfo[index][swipeLeft ? 'maxLeft' : 'maxRight'];\n        var targetPosition = position + (swipeLeft ? -1 : 1) * maxDeltaX * transformPercentage;\n\n        var _this$getSlideScaleAn2 = _this.getSlideScaleAndOpacity(targetPosition),\n            scale = _this$getSlideScaleAn2.scale,\n            opacity = _this$getSlideScaleAn2.opacity;\n\n        var zIndex = slide.zIndex;\n\n        if (Math.abs(slideIndex) === 1) {\n          if (_this.centerOffset(slideIndex) < _this.centerOffset(0)) {\n            zIndex = _this.maxZIndex;\n            tempShift = true;\n          }\n        }\n\n        return _extends({}, slide, {\n          position: targetPosition,\n          scale: scale,\n          opacity: opacity,\n          zIndex: zIndex\n        });\n      });\n\n      _this.setState({\n        renderedSlides: newRenderedSlides,\n        tempShift: tempShift\n      });\n    };\n\n    _this.resetSlides = function () {\n      var renderedSlides = _this.state.renderedSlides;\n      var newDefault = renderedSlides.map(function (slide) {\n        var _this$safeGetSlideInf2 = _this.safeGetSlideInfo(slide.slideIndex),\n            opacity = _this$safeGetSlideInf2.opacity,\n            scale = _this$safeGetSlideInf2.scale,\n            position = _this$safeGetSlideInf2.position;\n\n        return _extends({}, slide, {\n          zIndex: _this.getZIndex(slide.slideIndex),\n          opacity: opacity,\n          scale: scale,\n          position: position\n        });\n      });\n\n      _this.setState(function () {\n        return {\n          renderedSlides: newDefault,\n          swipRight: false\n        };\n      }, _this.debouncedClearInvisibleSlide);\n    };\n\n    _this.onSwipeEnd = function () {\n      var swipeStarted = _this.state.swipeStarted;\n      if (!swipeStarted) return;\n      var renderedSlides = _this.state.renderedSlides;\n      var newCenterSlide = renderedSlides.find(function (_ref7) {\n        var zIndex = _ref7.zIndex;\n        return zIndex === _this.maxZIndex;\n      });\n\n      _this.moveCarousel((newCenterSlide === null || newCenterSlide === void 0 ? void 0 : newCenterSlide.slideIndex) || 0);\n\n      _this.setState({\n        tempShift: false\n      });\n    };\n\n    _this.goNext = function () {\n      _this.moveCarousel(1);\n    };\n\n    _this.goBack = function () {\n      _this.moveCarousel(-1);\n    };\n\n    _this.swipeTo = function (steps) {\n      _this.moveCarousel(steps);\n    };\n\n    var _this$initializePrope = _this.initializeProperties(true),\n        renderedSlides = _this$initializePrope.renderedSlides,\n        slideInfoMap = _this$initializePrope.slideInfoMap,\n        slidePerSide = _this$initializePrope.slidePerSide,\n        sortedSlideInfo = _this$initializePrope.sortedSlideInfo,\n        centerPosition = _this$initializePrope.centerPosition,\n        renderedSlidePerSide = _this$initializePrope.renderedSlidePerSide;\n\n    var onActiveSlideChange = _this.props.onActiveSlideChange;\n    _this.slideInfoMap = slideInfoMap;\n    _this.sortedSlideInfo = sortedSlideInfo;\n    _this.slidePerSide = slidePerSide;\n    _this.height = _this.props.height || 0;\n    _this.listRef = react__WEBPACK_IMPORTED_MODULE_0___default().createRef();\n    _this.clearSlideTimeout = null;\n    _this.keyCount = props.data.length;\n    _this.addedSlide = 0;\n    _this.centerPosition = centerPosition;\n    _this.maxZIndex = 100;\n    _this.renderedSlidePerSide = renderedSlidePerSide;\n\n    if (onActiveSlideChange) {\n      onActiveSlideChange(0);\n    }\n\n    _this.state = {\n      initalSwipeX: 0,\n      swipeStarted: false,\n      renderedSlides: renderedSlides,\n      prevRenderedSlides: [].concat(renderedSlides),\n      swipePositionInfo: [],\n      swipRight: false,\n      tempShift: false\n    };\n    return _this;\n  }\n\n  var _proto = StackedCarousel.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.updateHeight();\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    clearTimeout(this.clearSlideTimeout);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    if (!shouldRecaclculate(this.props, prevProps)) return;\n\n    var _this$initializePrope2 = this.initializeProperties(this.props.maxVisibleSlide !== prevProps.maxVisibleSlide),\n        slideInfoMap = _this$initializePrope2.slideInfoMap,\n        slidePerSide = _this$initializePrope2.slidePerSide,\n        newRenderedSlides = _this$initializePrope2.newRenderedSlides,\n        sortedSlideInfo = _this$initializePrope2.sortedSlideInfo,\n        centerPosition = _this$initializePrope2.centerPosition;\n\n    this.slideInfoMap = slideInfoMap;\n    this.sortedSlideInfo = sortedSlideInfo;\n    this.slidePerSide = slidePerSide;\n    this.centerPosition = centerPosition;\n    this.setState(function () {\n      return {\n        initalSwipeX: 0,\n        renderedSlides: newRenderedSlides,\n        prevRenderedSlides: [].concat(newRenderedSlides),\n        swipRight: false\n      };\n    }, this.updateHeight);\n  };\n\n  _proto.getSwipeX = function getSwipeX(e) {\n    if (e.type[0] === 'm') return e.clientX;\n\n    try {\n      var _e$touches$, _e$changedTouches$;\n\n      return ((_e$touches$ = e.touches[0]) === null || _e$touches$ === void 0 ? void 0 : _e$touches$.clientX) || ((_e$changedTouches$ = e.changedTouches[0]) === null || _e$changedTouches$ === void 0 ? void 0 : _e$changedTouches$.clientX);\n    } catch (_unused) {\n      throw Error('Something went wrong with getting mouse position');\n    }\n  };\n\n  _proto.render = function render() {\n    var _this2 = this;\n\n    var _this$state2 = this.state,\n        swipeStarted = _this$state2.swipeStarted,\n        renderedSlides = _this$state2.renderedSlides,\n        swipRight = _this$state2.swipRight,\n        tempShift = _this$state2.tempShift;\n    var _this$props5 = this.props,\n        Component = _this$props5.slideComponent,\n        _this$props5$transiti = _this$props5.transitionTime,\n        transitionTime = _this$props5$transiti === void 0 ? StackedCarousel.defaultTransitionTime : _this$props5$transiti,\n        className = _this$props5.className,\n        data = _this$props5.data,\n        slideWidth = _this$props5.slideWidth,\n        customTransition = _this$props5.customTransition,\n        carouselWidth = _this$props5.carouselWidth,\n        useGrabCursor = _this$props5.useGrabCursor,\n        height = _this$props5.height;\n    var cursor = useGrabCursor && (swipeStarted ? 'grabbing' : 'grab') || 'default';\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n      className: \"react-stacked-center-carousel \" + (className || ''),\n      onMouseDown: this.onSwipeStart,\n      onMouseUp: this.onSwipeEnd,\n      onMouseMove: this.onSwipe,\n      onMouseLeave: this.onSwipeEnd,\n      onTouchStart: this.onSwipeStart,\n      onTouchMove: this.onSwipe,\n      onTouchEnd: this.onSwipeEnd,\n      ref: this.listRef,\n      style: {\n        width: carouselWidth,\n        height: height || this.height,\n        position: 'relative',\n        overflow: 'hidden',\n        cursor: cursor\n      }\n    }, renderedSlides.map(function (_ref8) {\n      var opacity = _ref8.opacity,\n          slideIndex = _ref8.slideIndex,\n          dataIndex = _ref8.dataIndex,\n          position = _ref8.position,\n          scale = _ref8.scale,\n          key = _ref8.key,\n          zIndex = _ref8.zIndex;\n      var ID = dataIndex === -1 ? \"hidden-\" + key : slideIndex;\n      var zDuration = transitionTime * (swipRight ? 0.6 : 1);\n      var transition = swipeStarted ? 'none' : customTransition || \"all \" + transitionTime + \"ms ease, z-index \" + zDuration + \"ms ease\";\n      var isCenterSlide = tempShift ? zIndex === _this2.maxZIndex : slideIndex === 0;\n      return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        key: key,\n        className: \"react-stacked-center-carousel-slide-\" + ID,\n        draggable: false,\n        style: {\n          position: 'absolute',\n          display: 'flex',\n          left: \"calc(50% - \" + slideWidth / 2 + \"px)\",\n          transform: \"translateX(\" + position + \"px) scale(\" + scale + \")\",\n          width: slideWidth,\n          transition: transition,\n          opacity: opacity,\n          zIndex: zIndex\n        }\n      }, dataIndex !== -1 && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Component, {\n        dataIndex: dataIndex,\n        data: data,\n        slideIndex: slideIndex,\n        isCenterSlide: isCenterSlide,\n        swipeTo: _this2.swipeTo\n      }));\n    }));\n  };\n\n  return StackedCarousel;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().PureComponent));\nStackedCarousel.defaultScaleFactor = 0.85;\nStackedCarousel.defaultTransitionTime = 450;\n\nfunction shouldRecaclculate(prop1, prop2) {\n  var _prop1$customScales, _prop2$customScales;\n\n  if (prop1.slideWidth !== prop2.slideWidth || prop1.carouselWidth !== prop2.carouselWidth || prop1.maxVisibleSlide !== prop2.maxVisibleSlide || prop1.currentVisibleSlide !== prop2.currentVisibleSlide || prop1.fadeDistance !== prop2.fadeDistance || ((_prop1$customScales = prop1.customScales) === null || _prop1$customScales === void 0 ? void 0 : _prop1$customScales.join('')) !== ((_prop2$customScales = prop2.customScales) === null || _prop2$customScales === void 0 ? void 0 : _prop2$customScales.join(''))) return true;\n  return false;\n}\n\nfunction ResponsiveContainer(props) {\n  var render = props.render,\n      carouselRef = props.carouselRef;\n\n  var _useResizeDetector = (0,react_resize_detector__WEBPACK_IMPORTED_MODULE_1__.useResizeDetector)(),\n      width = _useResizeDetector.width,\n      ref = _useResizeDetector.ref;\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    ref: ref,\n    className: 'stacked-carousel-responsive-container',\n    style: {\n      width: '100%'\n    }\n  }, width && render(width, carouselRef));\n}\n\n\n//# sourceMappingURL=index.modern.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3Qtc3RhY2tlZC1jZW50ZXItY2Fyb3VzZWxAMS4wLjE0X3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL3JlYWN0LXN0YWNrZWQtY2VudGVyLWNhcm91c2VsL2Rpc3QvaW5kZXgubW9kZXJuLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTBCO0FBQ2dDOztBQUUxRDtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLDZCQUE2QiwwQkFBMEI7QUFDdkQ7QUFDQTs7QUFFQSxrQ0FBa0MsbUJBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsK0JBQStCO0FBQzlFLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTs7QUFFQSxtRkFBbUYsNEJBQTRCO0FBQy9HO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMERBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBEQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0JBQXNCLDBEQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUMsQ0FBQyw0REFBbUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHdFQUFpQjtBQUM1QztBQUNBOztBQUVBLFNBQVMsMERBQW1CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRWdEO0FBQ2hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXV0aC1hcHAvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3Qtc3RhY2tlZC1jZW50ZXItY2Fyb3VzZWxAMS4wLjE0X3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL3JlYWN0LXN0YWNrZWQtY2VudGVyLWNhcm91c2VsL2Rpc3QvaW5kZXgubW9kZXJuLmpzPzViNGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVJlc2l6ZURldGVjdG9yIH0gZnJvbSAncmVhY3QtcmVzaXplLWRldGVjdG9yJztcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuXG4gIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkge1xuICB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKGl0KSByZXR1cm4gKGl0ID0gaXQuY2FsbChvKSkubmV4dC5iaW5kKGl0KTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbnZhciBTdGFja2VkQ2Fyb3VzZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRQdXJlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFN0YWNrZWRDYXJvdXNlbCwgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFN0YWNrZWRDYXJvdXNlbChwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JFB1cmVDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcblxuICAgIF90aGlzLnZhbGlkYXRlUHJvcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBzd2lwZVNwZWVkID0gX3RoaXMkcHJvcHMuc3dpcGVTcGVlZCxcbiAgICAgICAgICBjdXJyZW50VmlzaWJsZVNsaWRlID0gX3RoaXMkcHJvcHMuY3VycmVudFZpc2libGVTbGlkZSxcbiAgICAgICAgICBtYXhWaXNpYmxlU2xpZGUgPSBfdGhpcyRwcm9wcy5tYXhWaXNpYmxlU2xpZGUsXG4gICAgICAgICAgZmFkZURpc3RhbmNlID0gX3RoaXMkcHJvcHMuZmFkZURpc3RhbmNlLFxuICAgICAgICAgIGN1c3RvbVNjYWxlcyA9IF90aGlzJHByb3BzLmN1c3RvbVNjYWxlcyxcbiAgICAgICAgICBkYXRhID0gX3RoaXMkcHJvcHMuZGF0YTtcblxuICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgKG1heFZpc2libGVTbGlkZSArIDEpIC8gMikge1xuICAgICAgICB0aHJvdyBFcnJvcigneW91IG11c3QgaGF2ZSBtb3JlIHRoYW4gKG1heFZpc2libGVTbGlkZSArIDEpIC8gMiBkYXRhIGl0ZW0nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnRWaXNpYmxlU2xpZGUgJiYgY3VycmVudFZpc2libGVTbGlkZSAlIDIgIT09IDEgfHwgbWF4VmlzaWJsZVNsaWRlICUgMiAhPT0gMSkge1xuICAgICAgICB0aHJvdyBFcnJvcignY3VycmVudFZpc2libGVTbGlkZSBvciBtYXhWaXNpYmxlU2xpZGUgbXVzdCBiZSBhbiBvZGQgbnVtYmVyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50VmlzaWJsZVNsaWRlICYmIGN1cnJlbnRWaXNpYmxlU2xpZGUgPiBtYXhWaXNpYmxlU2xpZGUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2N1cnJlbnRWaXNpYmxlU2xpZGUgbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4VmlzaWJsZVNsaWRlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmYWRlRGlzdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZmFkZURpc3RhbmNlID4gMSB8fCBmYWRlRGlzdGFuY2UgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ2ZhZGVEaXN0YW5jZSBpcyBhIHBlcmNlbnRhZ2UgdmFsdWUgaW4gdGhlIHJhbmdlIG9mIDAgLSAxJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGN1c3RvbVNjYWxlcyAmJiBjdXN0b21TY2FsZXMubGVuZ3RoICE9PSAobWF4VmlzaWJsZVNsaWRlICsgMykgLyAyKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdjdXN0b21TY2FsZXMgbXVzdCBoYXZlIGxlbmdoIChtYXhWaXNpYmxlU2xpZGUgKyAzKSAvIDInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN3aXBlU3BlZWQgJiYgKHN3aXBlU3BlZWQgPiAwLjk5IHx8IHN3aXBlU3BlZWQgPCAwLjAxKSkge1xuICAgICAgICB0aHJvdyBFcnJvcignc3dpcGVTcGVlZCBtdXN0IGhhdmUgYSB2YWx1ZSBiZXR3ZWVuIDAuMDEgYW5kIDAuOTknKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuaW5pdGlhbGl6ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoY29uc3RydWN0b3IpIHtcbiAgICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0cnVjdG9yID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnZhbGlkYXRlUHJvcHMoKTtcblxuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGNhcm91c2VsV2lkdGggPSBfdGhpcyRwcm9wczIuY2Fyb3VzZWxXaWR0aCxcbiAgICAgICAgICBzbGlkZVdpZHRoID0gX3RoaXMkcHJvcHMyLnNsaWRlV2lkdGgsXG4gICAgICAgICAgY3VycmVudFZpc2libGVEaXNwbGF5U2xpZGUgPSBfdGhpcyRwcm9wczIuY3VycmVudFZpc2libGVTbGlkZSxcbiAgICAgICAgICBtYXhWaXNpYmxlU2xpZGUgPSBfdGhpcyRwcm9wczIubWF4VmlzaWJsZVNsaWRlO1xuICAgICAgdmFyIGN1cnJlbnRWaXNpYmxlU2xpZGVzID0gY3VycmVudFZpc2libGVEaXNwbGF5U2xpZGUgfHwgbWF4VmlzaWJsZVNsaWRlO1xuICAgICAgdmFyIHZpc2libGVTbGlkZVBlclNpZGUgPSAoY3VycmVudFZpc2libGVTbGlkZXMgLSAxKSAvIDI7XG4gICAgICB2YXIgc2xpZGVQZXJTaWRlID0gTWF0aC5tYXgodmlzaWJsZVNsaWRlUGVyU2lkZSArIDEsIDEpO1xuICAgICAgdmFyIHRvdGFsUmVuZGVyQ291bnQgPSBtYXhWaXNpYmxlU2xpZGUgKyAyO1xuICAgICAgdmFyIHJlbmRlcmVkU2xpZGVQZXJTaWRlID0gKG1heFZpc2libGVTbGlkZSArIDEpIC8gMjtcblxuICAgICAgdmFyIF90aGlzJGNhbGN1bGF0ZVNjYWxlQSA9IF90aGlzLmNhbGN1bGF0ZVNjYWxlQW5kT2Zmc2V0cyhzbGlkZVBlclNpZGUpLFxuICAgICAgICAgIG9mZnNldHMgPSBfdGhpcyRjYWxjdWxhdGVTY2FsZUEub2Zmc2V0cyxcbiAgICAgICAgICBzY2FsZWRPZmZzZXRzID0gX3RoaXMkY2FsY3VsYXRlU2NhbGVBLnNjYWxlZE9mZnNldHMsXG4gICAgICAgICAgc2NhbGVzID0gX3RoaXMkY2FsY3VsYXRlU2NhbGVBLnNjYWxlcztcblxuICAgICAgdmFyIG5ld1JlbmRlcmVkU2xpZGVzID0gY29uc3RydWN0b3IgPyBBcnJheSh0b3RhbFJlbmRlckNvdW50KS5maWxsKG51bGwpIDogX3RoaXMuc3RhdGUucmVuZGVyZWRTbGlkZXMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBzbGlkZUluZGV4ID0gX3JlZi5zbGlkZUluZGV4LFxuICAgICAgICAgICAgZGF0YUluZGV4ID0gX3JlZi5kYXRhSW5kZXg7XG4gICAgICAgIHJldHVybiBkYXRhSW5kZXggPT09IC0xIHx8IE1hdGguYWJzKHNsaWRlSW5kZXgpIDw9IF90aGlzLnNsaWRlUGVyU2lkZTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHNsaWRlSW5mb01hcCA9IHt9O1xuICAgICAgdmFyIG5ld0NlbnRlclNsaWRlUmVsYXRpdmVJbmRleCA9IGNvbnN0cnVjdG9yID8gKHRvdGFsUmVuZGVyQ291bnQgLSAxKSAvIDIgOiBuZXdSZW5kZXJlZFNsaWRlcy5maW5kSW5kZXgoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciBzbGlkZUluZGV4ID0gX3JlZjIuc2xpZGVJbmRleDtcbiAgICAgICAgcmV0dXJuIHNsaWRlSW5kZXggPT09IDA7XG4gICAgICB9KTtcbiAgICAgIHZhciBuZXdDZW50ZXJEYXRhSW5kZXggPSBjb25zdHJ1Y3RvciA/IDAgOiBuZXdSZW5kZXJlZFNsaWRlc1tuZXdDZW50ZXJTbGlkZVJlbGF0aXZlSW5kZXhdLmRhdGFJbmRleDtcbiAgICAgIHZhciBmaWxsZWRXaWR0aCA9IDA7XG4gICAgICB2YXIgY2VudGVyUG9zaXRpb24gPSBjYXJvdXNlbFdpZHRoIC8gMiAtIHNsaWRlV2lkdGggLyAyO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChhYnNJbmRleCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0c1thYnNJbmRleF07XG4gICAgICAgIHZhciBzbGlkZVNjYWxlID0gc2NhbGVzW2Fic0luZGV4XTtcbiAgICAgICAgdmFyIGN1cnJlbnRPZmZTZXQgPSBmaWxsZWRXaWR0aCArIG9mZnNldDtcbiAgICAgICAgWy1hYnNJbmRleCwgYWJzSW5kZXhdLmZvckVhY2goZnVuY3Rpb24gKHNsaWRlSW5kZXgpIHtcbiAgICAgICAgICB2YXIgcmVsYXRpdmVJbmRleCA9IG5ld0NlbnRlclNsaWRlUmVsYXRpdmVJbmRleCArIHNsaWRlSW5kZXg7XG4gICAgICAgICAgdmFyIHBvc2l0aW9uID0gc2xpZGVJbmRleCA+PSAwID8gY3VycmVudE9mZlNldCA6IC1jdXJyZW50T2ZmU2V0O1xuICAgICAgICAgIHZhciBvcGFjaXR5ID0gYWJzSW5kZXggPT09IHNsaWRlUGVyU2lkZSA/IDAgOiAxO1xuXG4gICAgICAgICAgdmFyIGRhdGFJbmRleCA9IF90aGlzLm1vZERhdGFSYW5nZShuZXdDZW50ZXJEYXRhSW5kZXggKyBzbGlkZUluZGV4KTtcblxuICAgICAgICAgIG5ld1JlbmRlcmVkU2xpZGVzW3JlbGF0aXZlSW5kZXhdID0ge1xuICAgICAgICAgICAgZGF0YUluZGV4OiBkYXRhSW5kZXgsXG4gICAgICAgICAgICBzY2FsZTogc2xpZGVTY2FsZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgIHNsaWRlSW5kZXg6IHNsaWRlSW5kZXgsXG4gICAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5LFxuICAgICAgICAgICAgekluZGV4OiByZW5kZXJlZFNsaWRlUGVyU2lkZSAtIE1hdGguYWJzKHNsaWRlSW5kZXgpLFxuICAgICAgICAgICAga2V5OiBjb25zdHJ1Y3RvciA/IHNsaWRlSW5kZXggOiBuZXdSZW5kZXJlZFNsaWRlc1tyZWxhdGl2ZUluZGV4XS5rZXlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHNsaWRlSW5mb01hcFtzbGlkZUluZGV4XSA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgIHNjYWxlOiBzbGlkZVNjYWxlLFxuICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYWJzSW5kZXggIT09IDApIGZpbGxlZFdpZHRoICs9IHNjYWxlZE9mZnNldHNbYWJzSW5kZXhdO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgYWJzSW5kZXggPSAwOyBhYnNJbmRleCA8PSBzbGlkZVBlclNpZGU7IGFic0luZGV4KyspIHtcbiAgICAgICAgX2xvb3AoYWJzSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gLXNsaWRlUGVyU2lkZTsgaSA8PSBzbGlkZVBlclNpZGU7IGkrKykge1xuICAgICAgICBzbGlkZUluZm9NYXBbaV0ubWF4VHJhbnNmb3JtRGlzdGFuY2UgPSB7fTtcbiAgICAgICAgc2xpZGVJbmZvTWFwW2ldLm1heFRyYW5zZm9ybVNjYWxlID0ge307XG4gICAgICAgIHNsaWRlSW5mb01hcFtpXS5tYXhUcmFuc2Zvcm1PcGFjaXR5ID0ge1xuICAgICAgICAgIGxlZnQ6IGkgPT09IC1zbGlkZVBlclNpZGUgKyAxIHx8IGkgPT09IHNsaWRlUGVyU2lkZSA/IDEgOiAwLFxuICAgICAgICAgIHJpZ2h0OiBpID09PSAtc2xpZGVQZXJTaWRlIHx8IGkgPT09IHNsaWRlUGVyU2lkZSAtIDEgPyAxIDogMFxuICAgICAgICB9O1xuICAgICAgICBzbGlkZUluZm9NYXBbaV0uc2xpZGVJbmRleCA9IGk7XG5cbiAgICAgICAgaWYgKGkgPT09IC1zbGlkZVBlclNpZGUpIHtcbiAgICAgICAgICBzbGlkZUluZm9NYXBbaV0ubWF4VHJhbnNmb3JtRGlzdGFuY2UubGVmdCA9IDA7XG4gICAgICAgICAgc2xpZGVJbmZvTWFwW2ldLm1heFRyYW5zZm9ybVNjYWxlLmxlZnQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNsaWRlSW5mb01hcFtpXS5tYXhUcmFuc2Zvcm1EaXN0YW5jZS5sZWZ0ID0gc2xpZGVJbmZvTWFwW2ldLnBvc2l0aW9uIC0gc2xpZGVJbmZvTWFwW2kgLSAxXS5wb3NpdGlvbjtcbiAgICAgICAgICBzbGlkZUluZm9NYXBbaV0ubWF4VHJhbnNmb3JtU2NhbGUubGVmdCA9IE1hdGguYWJzKHNsaWRlSW5mb01hcFtpXS5zY2FsZSAtIHNsaWRlSW5mb01hcFtpIC0gMV0uc2NhbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPT09IHNsaWRlUGVyU2lkZSkge1xuICAgICAgICAgIHNsaWRlSW5mb01hcFtpXS5tYXhUcmFuc2Zvcm1EaXN0YW5jZS5yaWdodCA9IDA7XG4gICAgICAgICAgc2xpZGVJbmZvTWFwW2ldLm1heFRyYW5zZm9ybVNjYWxlLnJpZ2h0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzbGlkZUluZm9NYXBbaV0ubWF4VHJhbnNmb3JtRGlzdGFuY2UucmlnaHQgPSBzbGlkZUluZm9NYXBbaSArIDFdLnBvc2l0aW9uIC0gc2xpZGVJbmZvTWFwW2ldLnBvc2l0aW9uO1xuICAgICAgICAgIHNsaWRlSW5mb01hcFtpXS5tYXhUcmFuc2Zvcm1TY2FsZS5yaWdodCA9IE1hdGguYWJzKHNsaWRlSW5mb01hcFtpICsgMV0uc2NhbGUgLSBzbGlkZUluZm9NYXBbaV0uc2NhbGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXhWaXNpYmxlU2xpZGUgPiBjdXJyZW50VmlzaWJsZVNsaWRlcykge1xuICAgICAgICB2YXIgbWF4UmVuZGVyZWRTbGlkZVBlclNpZGUgPSAobWF4VmlzaWJsZVNsaWRlICsgMSkgLyAyO1xuICAgICAgICB2YXIgY3VycmVudFNsaWRlUGVyU2lkZSA9IHNsaWRlUGVyU2lkZTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IGN1cnJlbnRTbGlkZVBlclNpZGUgKyAxOyBfaSA8PSBtYXhSZW5kZXJlZFNsaWRlUGVyU2lkZTsgX2krKykge1xuICAgICAgICAgIGZvciAodmFyIGRpcmVjdCA9IDE7IGRpcmVjdCA+PSAwOyBkaXJlY3QtLSkge1xuICAgICAgICAgICAgdmFyIGluc2VydEluZGV4ID0gbmV3Q2VudGVyU2xpZGVSZWxhdGl2ZUluZGV4ICsgKGRpcmVjdCA9PT0gMSA/IF9pIDogLV9pKTtcbiAgICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBpbnNlcnRJbmRleCArIChkaXJlY3QgPT09IDEgPyAtMSA6IDEpO1xuICAgICAgICAgICAgdmFyIHNsaWRlSW5kZXggPSBkaXJlY3QgPT09IDEgPyBfaSA6IC1faTtcbiAgICAgICAgICAgIHZhciBzY2FsZVBvc2l0aW9uSW5kZXggPSBjb25zdHJ1Y3RvciA/IHByZXZJbmRleCA6IGluc2VydEluZGV4O1xuICAgICAgICAgICAgbmV3UmVuZGVyZWRTbGlkZXNbaW5zZXJ0SW5kZXhdID0ge1xuICAgICAgICAgICAgICBzY2FsZTogbmV3UmVuZGVyZWRTbGlkZXNbc2NhbGVQb3NpdGlvbkluZGV4XS5zY2FsZSxcbiAgICAgICAgICAgICAgcG9zaXRpb246IG5ld1JlbmRlcmVkU2xpZGVzW3NjYWxlUG9zaXRpb25JbmRleF0ucG9zaXRpb24sXG4gICAgICAgICAgICAgIGtleTogY29uc3RydWN0b3IgPyAtc2xpZGVJbmRleCA6IG5ld1JlbmRlcmVkU2xpZGVzW2luc2VydEluZGV4XS5rZXksXG4gICAgICAgICAgICAgIGRhdGFJbmRleDogLTEsXG4gICAgICAgICAgICAgIHNsaWRlSW5kZXg6IHNsaWRlSW5kZXgsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgIHpJbmRleDogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvcnRlZFNsaWRlSW5mbyA9IE9iamVjdC52YWx1ZXMoc2xpZGVJbmZvTWFwKTtcbiAgICAgIHNvcnRlZFNsaWRlSW5mby5zb3J0KGZ1bmN0aW9uIChzbGlkZTEsIHNsaWRlMikge1xuICAgICAgICByZXR1cm4gc2xpZGUxLnBvc2l0aW9uIC0gc2xpZGUyLnBvc2l0aW9uO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXJlZFNsaWRlczogbmV3UmVuZGVyZWRTbGlkZXMsXG4gICAgICAgIGNlbnRlclNsaWRlUmVsYXRpdmVJbmRleDogbmV3Q2VudGVyU2xpZGVSZWxhdGl2ZUluZGV4LFxuICAgICAgICBzbGlkZUluZm9NYXA6IHNsaWRlSW5mb01hcCxcbiAgICAgICAgc2xpZGVQZXJTaWRlOiBzbGlkZVBlclNpZGUsXG4gICAgICAgIG5ld1JlbmRlcmVkU2xpZGVzOiBuZXdSZW5kZXJlZFNsaWRlcyxcbiAgICAgICAgc29ydGVkU2xpZGVJbmZvOiBzb3J0ZWRTbGlkZUluZm8sXG4gICAgICAgIGNlbnRlclBvc2l0aW9uOiBjZW50ZXJQb3NpdGlvbixcbiAgICAgICAgcmVuZGVyZWRTbGlkZVBlclNpZGU6IHJlbmRlcmVkU2xpZGVQZXJTaWRlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBfdGhpcy5jYWxjdWxhdGVTY2FsZUFuZE9mZnNldHMgPSBmdW5jdGlvbiAoc2xpZGVQZXJTaWRlKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgY2Fyb3VzZWxXaWR0aCA9IF90aGlzJHByb3BzMy5jYXJvdXNlbFdpZHRoLFxuICAgICAgICAgIHNsaWRlV2lkdGggPSBfdGhpcyRwcm9wczMuc2xpZGVXaWR0aCxcbiAgICAgICAgICBjdXN0b21TY2FsZXMgPSBfdGhpcyRwcm9wczMuY3VzdG9tU2NhbGVzLFxuICAgICAgICAgIGZhZGVEaXN0YW5jZSA9IF90aGlzJHByb3BzMy5mYWRlRGlzdGFuY2U7XG4gICAgICB2YXIgYXZhaWxhYmxlU3BhY2UgPSBjYXJvdXNlbFdpZHRoIC8gMiAtIHNsaWRlV2lkdGggLyAyO1xuICAgICAgdmFyIHNjYWxlcyA9IFsxXTtcbiAgICAgIHZhciBzY2FsZWRTbGlkZVdpZHRocyA9IFtzbGlkZVdpZHRoXTtcblxuICAgICAgZm9yICh2YXIgc2xpZGUgPSAxOyBzbGlkZSA8PSBzbGlkZVBlclNpZGU7IHNsaWRlKyspIHtcbiAgICAgICAgdmFyIHNjYWxlID0gY3VzdG9tU2NhbGVzID8gY3VzdG9tU2NhbGVzW3NsaWRlXSA6IE1hdGgucG93KFN0YWNrZWRDYXJvdXNlbC5kZWZhdWx0U2NhbGVGYWN0b3IsIHNsaWRlKTtcbiAgICAgICAgc2NhbGVzLnB1c2goc2NhbGUpO1xuICAgICAgICBzY2FsZWRTbGlkZVdpZHRocy5wdXNoKHNsaWRlV2lkdGggKiBzY2FsZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmNsdWRlZFNsaWRlV2lkdGhzID0gc2NhbGVkU2xpZGVXaWR0aHMuc2xpY2UoMSk7XG4gICAgICB2YXIgZmlsbGluZ1NwYWNlID0gYXZhaWxhYmxlU3BhY2U7XG5cbiAgICAgIGlmIChmYWRlRGlzdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmNsdWRlZFNsaWRlV2lkdGhzID0gc2NhbGVkU2xpZGVXaWR0aHMuc2xpY2UoMSwgc2xpZGVQZXJTaWRlKTtcbiAgICAgICAgZmlsbGluZ1NwYWNlID0gYXZhaWxhYmxlU3BhY2UgKiAoMSAtIGZhZGVEaXN0YW5jZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3RhbFNsaWRlV2lkdGggPSBpbmNsdWRlZFNsaWRlV2lkdGhzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSArIGI7XG4gICAgICB9LCAwKTtcbiAgICAgIHZhciBvZmZTZXRQZXJjZW50YWdlID0gdG90YWxTbGlkZVdpZHRoID8gZmlsbGluZ1NwYWNlIC8gdG90YWxTbGlkZVdpZHRoIDogMDtcbiAgICAgIHZhciBzY2FsZWRPZmZzZXRzID0gWzBdO1xuICAgICAgdmFyIG9mZnNldHMgPSBbMF07XG5cbiAgICAgIGZvciAodmFyIF9zbGlkZSA9IDE7IF9zbGlkZSA8PSBzbGlkZVBlclNpZGU7IF9zbGlkZSsrKSB7XG4gICAgICAgIHZhciBpc0N1c3RvbUZhZGUgPSBmYWRlRGlzdGFuY2UgIT09IHVuZGVmaW5lZCAmJiBfc2xpZGUgPT09IHNsaWRlUGVyU2lkZTtcbiAgICAgICAgdmFyIF9zY2FsZSA9IHNjYWxlc1tfc2xpZGVdO1xuICAgICAgICBzY2FsZWRPZmZzZXRzW19zbGlkZV0gPSBpc0N1c3RvbUZhZGUgPyBmYWRlRGlzdGFuY2UgKiBhdmFpbGFibGVTcGFjZSA6IHNsaWRlV2lkdGggKiBfc2NhbGUgKiBvZmZTZXRQZXJjZW50YWdlO1xuICAgICAgICBvZmZzZXRzW19zbGlkZV0gPSBzY2FsZWRPZmZzZXRzW19zbGlkZV0gKyBzbGlkZVdpZHRoICogKCgxIC0gX3NjYWxlKSAvIDIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBvZmZzZXRzOiBvZmZzZXRzLFxuICAgICAgICBzY2FsZWRPZmZzZXRzOiBzY2FsZWRPZmZzZXRzLFxuICAgICAgICBzY2FsZXM6IHNjYWxlc1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0WkluZGV4ID0gZnVuY3Rpb24gKHNsaWRlSW5kZXgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5yZW5kZXJlZFNsaWRlUGVyU2lkZSAtIE1hdGguYWJzKHNsaWRlSW5kZXgpO1xuICAgIH07XG5cbiAgICBfdGhpcy51cGRhdGVIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaGVpZ2h0ID0gX3RoaXMucHJvcHMuaGVpZ2h0O1xuICAgICAgaWYgKGhlaWdodCkgcmV0dXJuO1xuXG4gICAgICB2YXIgX3RoaXMkZ2V0U2xpZGVET01JbmZvID0gX3RoaXMuZ2V0U2xpZGVET01JbmZvKDApLFxuICAgICAgICAgIHNsaWRlRE9NID0gX3RoaXMkZ2V0U2xpZGVET01JbmZvLnNsaWRlRE9NO1xuXG4gICAgICB2YXIgcGFyc2VkSGVpZ2h0ID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoc2xpZGVET00pLmhlaWdodCk7XG5cbiAgICAgIGlmIChwYXJzZWRIZWlnaHQgIT09IF90aGlzLmhlaWdodCkge1xuICAgICAgICBfdGhpcy5oZWlnaHQgPSBwYXJzZWRIZWlnaHQ7XG5cbiAgICAgICAgX3RoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMubW9kRGF0YVJhbmdlID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgIHZhciBkYXRhID0gX3RoaXMucHJvcHMuZGF0YTtcbiAgICAgIHZhciBtID0gZGF0YS5sZW5ndGg7XG4gICAgICByZXR1cm4gKG4gJSBtICsgbSkgJSBtO1xuICAgIH07XG5cbiAgICBfdGhpcy5kZWJvdW5jZWRDbGVhckludmlzaWJsZVNsaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRyYW5zaXRpb25UaW1lID0gX3RoaXMucHJvcHMudHJhbnNpdGlvblRpbWU7XG4gICAgICBjbGVhclRpbWVvdXQoX3RoaXMuY2xlYXJTbGlkZVRpbWVvdXQpO1xuICAgICAgX3RoaXMuY2xlYXJTbGlkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KF90aGlzLmNsZWFyVXNlbGVzc1NsaWRlLCB0cmFuc2l0aW9uVGltZSAhPT0gdW5kZWZpbmVkID8gdHJhbnNpdGlvblRpbWUgOiBTdGFja2VkQ2Fyb3VzZWwuZGVmYXVsdFRyYW5zaXRpb25UaW1lKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuY2xlYXJVc2VsZXNzU2xpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5hZGRlZFNsaWRlID0gMDtcbiAgICAgIHZhciByZW5kZXJlZFNsaWRlcyA9IF90aGlzLnN0YXRlLnJlbmRlcmVkU2xpZGVzO1xuICAgICAgdmFyIG5ld1JlbmRlcmVkU2xpZGVzID0gcmVuZGVyZWRTbGlkZXMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICB2YXIgc2xpZGVJbmRleCA9IF9yZWYzLnNsaWRlSW5kZXgsXG4gICAgICAgICAgICBkYXRhSW5kZXggPSBfcmVmMy5kYXRhSW5kZXg7XG4gICAgICAgIHZhciBhYnNvbHV0ZVNsaWRlSW5kZXggPSBNYXRoLmFicyhzbGlkZUluZGV4KTtcblxuICAgICAgICBpZiAoYWJzb2x1dGVTbGlkZUluZGV4IDw9IF90aGlzLnNsaWRlUGVyU2lkZSB8fCBkYXRhSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcblxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICByZW5kZXJlZFNsaWRlczogbmV3UmVuZGVyZWRTbGlkZXNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5zYWZlR2V0U2xpZGVJbmZvID0gZnVuY3Rpb24gKHNsaWRlSW5kZXgpIHtcbiAgICAgIHZhciBwb3NpdGlvbkluZGV4ID0gc2xpZGVJbmRleDtcblxuICAgICAgaWYgKHBvc2l0aW9uSW5kZXggPiBfdGhpcy5zbGlkZVBlclNpZGUpIHtcbiAgICAgICAgcG9zaXRpb25JbmRleCA9IF90aGlzLnNsaWRlUGVyU2lkZTtcbiAgICAgIH0gZWxzZSBpZiAocG9zaXRpb25JbmRleCA8IC1fdGhpcy5zbGlkZVBlclNpZGUpIHtcbiAgICAgICAgcG9zaXRpb25JbmRleCA9IC1fdGhpcy5zbGlkZVBlclNpZGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcy5zbGlkZUluZm9NYXBbcG9zaXRpb25JbmRleF07XG4gICAgfTtcblxuICAgIF90aGlzLmdldEluc2VydGlvbkluZm8gPSBmdW5jdGlvbiAoc3RlcHMpIHtcbiAgICAgIHZhciBuZXdBZGRlZFNsaWRlSW5kZXggPSBzdGVwcyA+IDAgPyBfdGhpcy5zbGlkZVBlclNpZGUgLSBzdGVwcyArIDEgOiAtX3RoaXMuc2xpZGVQZXJTaWRlIC0gc3RlcHMgLSAxO1xuICAgICAgdmFyIHRhcmdldFNsaWRlSW5kZXggPSBzdGVwcyA+IDAgPyBfdGhpcy5zbGlkZVBlclNpZGUgOiAtX3RoaXMuc2xpZGVQZXJTaWRlO1xuXG4gICAgICB2YXIgcmVxdWlyZU1vcmVTbGlkZSA9IGZ1bmN0aW9uIHJlcXVpcmVNb3JlU2xpZGUoY3VycmVudCwgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBzdGVwcyA+IDAgPyBjdXJyZW50IDw9IHRhcmdldCA6IGN1cnJlbnQgPj0gdGFyZ2V0O1xuICAgICAgfTtcblxuICAgICAgdmFyIHVwZGF0ZUNvdW50ID0gc3RlcHMgPiAwID8gMSA6IC0xO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV3QWRkZWRTbGlkZUluZGV4OiBuZXdBZGRlZFNsaWRlSW5kZXgsXG4gICAgICAgIHRhcmdldFNsaWRlSW5kZXg6IHRhcmdldFNsaWRlSW5kZXgsXG4gICAgICAgIHJlcXVpcmVNb3JlU2xpZGU6IHJlcXVpcmVNb3JlU2xpZGUsXG4gICAgICAgIHVwZGF0ZUNvdW50OiB1cGRhdGVDb3VudFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgX3RoaXMubW92ZUNhcm91c2VsID0gZnVuY3Rpb24gKHN0ZXBzLCBkaXNhYmxlU3dpcGVSaWdodFN0YXRlKSB7XG4gICAgICBpZiAoZGlzYWJsZVN3aXBlUmlnaHRTdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRpc2FibGVTd2lwZVJpZ2h0U3RhdGUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbmRlcmVkU2xpZGVzID0gX3RoaXMuc3RhdGUucmVuZGVyZWRTbGlkZXM7XG4gICAgICB2YXIgb25BY3RpdmVTbGlkZUNoYW5nZSA9IF90aGlzLnByb3BzLm9uQWN0aXZlU2xpZGVDaGFuZ2U7XG4gICAgICB2YXIgbmV3Q2VudGVyRGF0YUluZGV4ID0gMDtcbiAgICAgIHZhciBuZXdTbGlkZXMgPSByZW5kZXJlZFNsaWRlcy5tYXAoZnVuY3Rpb24gKG9sZFNsaWRlKSB7XG4gICAgICAgIHZhciBzbGlkZUluZGV4ID0gb2xkU2xpZGUuc2xpZGVJbmRleCxcbiAgICAgICAgICAgIGRhdGFJbmRleCA9IG9sZFNsaWRlLmRhdGFJbmRleDtcbiAgICAgICAgaWYgKGRhdGFJbmRleCA9PT0gLTEpIHJldHVybiBvbGRTbGlkZTtcbiAgICAgICAgaWYgKHNsaWRlSW5kZXggPT09IDApIG5ld0NlbnRlckRhdGFJbmRleCA9IF90aGlzLm1vZERhdGFSYW5nZShkYXRhSW5kZXggKyBzdGVwcyk7XG4gICAgICAgIHZhciBuZXdTbGlkZUluZGV4ID0gc2xpZGVJbmRleCArIC1zdGVwcztcblxuICAgICAgICB2YXIgc2xpZGVJbmZvID0gX3RoaXMuc2FmZUdldFNsaWRlSW5mbyhuZXdTbGlkZUluZGV4KTtcblxuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIG9sZFNsaWRlLCB7XG4gICAgICAgICAgc2xpZGVJbmRleDogbmV3U2xpZGVJbmRleCxcbiAgICAgICAgICBwb3NpdGlvbjogc2xpZGVJbmZvLnBvc2l0aW9uLFxuICAgICAgICAgIHNjYWxlOiBzbGlkZUluZm8uc2NhbGUsXG4gICAgICAgICAgb3BhY2l0eTogc2xpZGVJbmZvLm9wYWNpdHksXG4gICAgICAgICAgekluZGV4OiBfdGhpcy5nZXRaSW5kZXgobmV3U2xpZGVJbmRleClcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHN0ZXBzICE9PSAwKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG1heFNsaWRlSW5kZXggPSBzdGVwcyA+IDAgPyBfdGhpcy5zbGlkZVBlclNpZGUgOiAtX3RoaXMuc2xpZGVQZXJTaWRlO1xuICAgICAgICAgIF90aGlzLmFkZGVkU2xpZGUgKz0gTWF0aC5hYnMoc3RlcHMpO1xuXG4gICAgICAgICAgdmFyIGluc2VydGlvbkluZm8gPSBfdGhpcy5nZXRJbnNlcnRpb25JbmZvKHN0ZXBzKTtcblxuICAgICAgICAgIHZhciBuZXdBZGRlZFNsaWRlSW5kZXggPSBpbnNlcnRpb25JbmZvLm5ld0FkZGVkU2xpZGVJbmRleDtcbiAgICAgICAgICB2YXIgcmVxdWlyZU1vcmVTbGlkZSA9IGluc2VydGlvbkluZm8ucmVxdWlyZU1vcmVTbGlkZSxcbiAgICAgICAgICAgICAgdXBkYXRlQ291bnQgPSBpbnNlcnRpb25JbmZvLnVwZGF0ZUNvdW50LFxuICAgICAgICAgICAgICB0YXJnZXRTbGlkZUluZGV4ID0gaW5zZXJ0aW9uSW5mby50YXJnZXRTbGlkZUluZGV4O1xuXG4gICAgICAgICAgd2hpbGUgKHJlcXVpcmVNb3JlU2xpZGUobmV3QWRkZWRTbGlkZUluZGV4LCB0YXJnZXRTbGlkZUluZGV4KSkge1xuICAgICAgICAgICAgdmFyIHNsaWRlQWxyZWFkeUV4aXN0ID0gbmV3U2xpZGVzLmZpbmQoZnVuY3Rpb24gKF9yZWY0KSB7XG4gICAgICAgICAgICAgIHZhciBzbGlkZUluZGV4ID0gX3JlZjQuc2xpZGVJbmRleDtcbiAgICAgICAgICAgICAgcmV0dXJuIHNsaWRlSW5kZXggPT09IG5ld0FkZGVkU2xpZGVJbmRleDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIXNsaWRlQWxyZWFkeUV4aXN0KSB7XG4gICAgICAgICAgICAgIHZhciBpbnNlcnRQb3NpdGlvbiA9IG5ld1NsaWRlcy5maW5kSW5kZXgoZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNsaWRlSW5kZXggPSBfcmVmNS5zbGlkZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICBkYXRhSW5kZXggPSBfcmVmNS5kYXRhSW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNsaWRlSW5kZXggPT09IG5ld0FkZGVkU2xpZGVJbmRleCAtIHVwZGF0ZUNvdW50ICYmIGRhdGFJbmRleCAhPT0gLTE7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB2YXIgX3RoaXMkc2xpZGVJbmZvTWFwJG1hID0gX3RoaXMuc2xpZGVJbmZvTWFwW21heFNsaWRlSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgc2NhbGUgPSBfdGhpcyRzbGlkZUluZm9NYXAkbWEuc2NhbGUsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IF90aGlzJHNsaWRlSW5mb01hcCRtYS5wb3NpdGlvbjtcblxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0RGF0YUluZGV4ID0gX3RoaXMubW9kRGF0YVJhbmdlKG5ld1NsaWRlc1tpbnNlcnRQb3NpdGlvbl0uZGF0YUluZGV4ICsgdXBkYXRlQ291bnQpO1xuXG4gICAgICAgICAgICAgIF90aGlzLmtleUNvdW50ICs9IDE7XG5cbiAgICAgICAgICAgICAgdmFyIHpJbmRleCA9IF90aGlzLmdldFpJbmRleChuZXdBZGRlZFNsaWRlSW5kZXgpO1xuXG4gICAgICAgICAgICAgIHZhciBpbnNlcnRTbGlkZSA9IHtcbiAgICAgICAgICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgekluZGV4OiB6SW5kZXggLSBfdGhpcy5hZGRlZFNsaWRlLFxuICAgICAgICAgICAgICAgIHNsaWRlSW5kZXg6IG5ld0FkZGVkU2xpZGVJbmRleCxcbiAgICAgICAgICAgICAgICBkYXRhSW5kZXg6IGluc2VydERhdGFJbmRleCxcbiAgICAgICAgICAgICAgICBrZXk6IF90aGlzLmtleUNvdW50XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIG5ld1NsaWRlcy5zcGxpY2Uoc3RlcHMgPiAwID8gaW5zZXJ0UG9zaXRpb24gKyAxIDogaW5zZXJ0UG9zaXRpb24sIDAsIGluc2VydFNsaWRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3QWRkZWRTbGlkZUluZGV4ICs9IHVwZGF0ZUNvdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0ZXBzICE9PSAwICYmIG9uQWN0aXZlU2xpZGVDaGFuZ2UpIHtcbiAgICAgICAgb25BY3RpdmVTbGlkZUNoYW5nZShuZXdDZW50ZXJEYXRhSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3dpcGVTdGFydGVkOiBmYWxzZSxcbiAgICAgICAgICByZW5kZXJlZFNsaWRlczogbmV3U2xpZGVzLFxuICAgICAgICAgIHN3aXBSaWdodDogZGlzYWJsZVN3aXBlUmlnaHRTdGF0ZSA/IGZhbHNlIDogc3RlcHMgPCAwID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnJlc2V0U2xpZGVzKCk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLmdldFNsaWRlRE9NSW5mbyA9IGZ1bmN0aW9uIChzbGlkZUluZGV4KSB7XG4gICAgICB2YXIgc2xpZGVXaWR0aCA9IF90aGlzLnByb3BzLnNsaWRlV2lkdGg7XG4gICAgICB2YXIgbGlzdFJlZiA9IF90aGlzLmxpc3RSZWYuY3VycmVudDtcbiAgICAgIHZhciBzbGlkZURPTSA9IGxpc3RSZWYuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInJlYWN0LXN0YWNrZWQtY2VudGVyLWNhcm91c2VsLXNsaWRlLVwiICsgc2xpZGVJbmRleClbMF07XG4gICAgICB2YXIgc2xpZGVSZWN0ID0gc2xpZGVET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIHZhciBfbGlzdFJlZiRnZXRCb3VuZGluZ0MgPSBsaXN0UmVmLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgIGNhcm91c2VsTGVmdCA9IF9saXN0UmVmJGdldEJvdW5kaW5nQy5sZWZ0O1xuXG4gICAgICB2YXIgc2NhbGUgPSBzbGlkZVJlY3Qud2lkdGggLyBzbGlkZVdpZHRoO1xuICAgICAgdmFyIGFkZGl0aW9uYWxPZmZzZXQgPSBzbGlkZVdpZHRoICogMC41ICogKDEgLSBzY2FsZSk7XG4gICAgICB2YXIgc2xpZGVPZmZzZXRMZWZ0ID0gc2xpZGVSZWN0LmxlZnQgLSBjYXJvdXNlbExlZnQgLSBhZGRpdGlvbmFsT2Zmc2V0O1xuICAgICAgdmFyIHNsaWRlQ2VudGVyT2Zmc2V0ID0gc2xpZGVPZmZzZXRMZWZ0IC0gX3RoaXMuY2VudGVyUG9zaXRpb247XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgIHNsaWRlRE9NOiBzbGlkZURPTSxcbiAgICAgICAgc2xpZGVDZW50ZXJPZmZzZXQ6IHNsaWRlQ2VudGVyT2Zmc2V0XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRTbGlkZVNjYWxlQW5kT3BhY2l0eSA9IGZ1bmN0aW9uIChjZW50ZXJPZmZzZXQpIHtcbiAgICAgIHZhciB0YXJnZXRTbGlkZSA9IF90aGlzLnNvcnRlZFNsaWRlSW5mby5maW5kKGZ1bmN0aW9uIChfcmVmNikge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBfcmVmNi5wb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChwb3NpdGlvbikgPj0gY2VudGVyT2Zmc2V0O1xuICAgICAgfSkgfHwgX3RoaXMuc29ydGVkU2xpZGVJbmZvW190aGlzLnNvcnRlZFNsaWRlSW5mby5sZW5ndGggLSAxXTtcblxuICAgICAgdmFyIHBvc2l0aW9uID0gdGFyZ2V0U2xpZGUucG9zaXRpb24sXG4gICAgICAgICAgc2xpZGVJbmRleCA9IHRhcmdldFNsaWRlLnNsaWRlSW5kZXgsXG4gICAgICAgICAgc2NhbGUgPSB0YXJnZXRTbGlkZS5zY2FsZSxcbiAgICAgICAgICBtYXhUcmFuc2Zvcm1EaXN0YW5jZSA9IHRhcmdldFNsaWRlLm1heFRyYW5zZm9ybURpc3RhbmNlLFxuICAgICAgICAgIG1heFRyYW5zZm9ybVNjYWxlID0gdGFyZ2V0U2xpZGUubWF4VHJhbnNmb3JtU2NhbGUsXG4gICAgICAgICAgbWF4VHJhbnNmb3JtT3BhY2l0eSA9IHRhcmdldFNsaWRlLm1heFRyYW5zZm9ybU9wYWNpdHksXG4gICAgICAgICAgb3BhY2l0eSA9IHRhcmdldFNsaWRlLm9wYWNpdHk7XG4gICAgICB2YXIgb2Zmc2V0ID0gTWF0aC5jZWlsKHBvc2l0aW9uKSAtIGNlbnRlck9mZnNldDtcbiAgICAgIHZhciBvZmZzZXRQZXJjZW50YWdlID0gbWF4VHJhbnNmb3JtRGlzdGFuY2UubGVmdCA9PT0gMCA/IDAgOiBvZmZzZXQgLyBtYXhUcmFuc2Zvcm1EaXN0YW5jZS5sZWZ0ICogKHNsaWRlSW5kZXggPD0gMCA/IC0xIDogMSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2FsZTogc2NhbGUgKyBtYXhUcmFuc2Zvcm1TY2FsZS5sZWZ0ICogb2Zmc2V0UGVyY2VudGFnZSxcbiAgICAgICAgb3BhY2l0eTogb3BhY2l0eSArIG1heFRyYW5zZm9ybU9wYWNpdHkubGVmdCAqIG9mZnNldFBlcmNlbnRhZ2VcbiAgICAgIH07XG4gICAgfTtcblxuICAgIF90aGlzLmNlbnRlck9mZnNldCA9IGZ1bmN0aW9uIChzbGlkZUluZGV4KSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0U2xpZGVET01JbmZvMiA9IF90aGlzLmdldFNsaWRlRE9NSW5mbyhzbGlkZUluZGV4KSxcbiAgICAgICAgICBzbGlkZUNlbnRlck9mZnNldCA9IF90aGlzJGdldFNsaWRlRE9NSW5mbzIuc2xpZGVDZW50ZXJPZmZzZXQ7XG5cbiAgICAgIHJldHVybiBNYXRoLmFicyhfdGhpcy5zbGlkZUluZm9NYXBbMF0ucG9zaXRpb24gLSBzbGlkZUNlbnRlck9mZnNldCk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uU3dpcGVTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgb25BY3RpdmVTbGlkZUNoYW5nZSA9IF90aGlzJHByb3BzNC5vbkFjdGl2ZVNsaWRlQ2hhbmdlLFxuICAgICAgICAgIGRpc2FibGVTd2lwZSA9IF90aGlzJHByb3BzNC5kaXNhYmxlU3dpcGU7XG4gICAgICBpZiAoZGlzYWJsZVN3aXBlKSByZXR1cm47XG5cbiAgICAgIHZhciBpbml0YWxTd2lwZVggPSBfdGhpcy5nZXRTd2lwZVgoZSk7XG5cbiAgICAgIHZhciByZW5kZXJlZFNsaWRlcyA9IF90aGlzLnN0YXRlLnJlbmRlcmVkU2xpZGVzO1xuICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmNsZWFyU2xpZGVUaW1lb3V0KTtcbiAgICAgIHZhciBzaGlmdERpcmVjdGlvbiA9IDA7XG4gICAgICB2YXIgY2VudGVyRGF0YUluZGV4ID0gMDtcbiAgICAgIGlmIChfdGhpcy5jZW50ZXJPZmZzZXQoLTEpIDwgX3RoaXMuY2VudGVyT2Zmc2V0KDApKSBzaGlmdERpcmVjdGlvbiA9IDE7ZWxzZSBpZiAoX3RoaXMuY2VudGVyT2Zmc2V0KDEpIDwgX3RoaXMuY2VudGVyT2Zmc2V0KDApKSBzaGlmdERpcmVjdGlvbiA9IC0xO1xuICAgICAgdmFyIG5ld1JlbmRlcmVkU2xpZGVzID0gW107XG4gICAgICB2YXIgc3dpcGVQb3NpdGlvbkluZm8gPSBbXTtcblxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShyZW5kZXJlZFNsaWRlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBzbGlkZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICB2YXIgc2xpZGVJbmRleCA9IHNsaWRlLnNsaWRlSW5kZXgsXG4gICAgICAgICAgICBkYXRhSW5kZXggPSBzbGlkZS5kYXRhSW5kZXg7XG5cbiAgICAgICAgaWYgKGRhdGFJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBuZXdSZW5kZXJlZFNsaWRlcy5wdXNoKHNsaWRlKTtcbiAgICAgICAgICBzd2lwZVBvc2l0aW9uSW5mby5wdXNoKHtcbiAgICAgICAgICAgIHNsaWRlSW5kZXg6IHNsaWRlSW5kZXgsXG4gICAgICAgICAgICBtYXhMZWZ0OiAwLFxuICAgICAgICAgICAgbWF4UmlnaHQ6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdTbGlkZUluZGV4ID0gc2xpZGVJbmRleCArIHNoaWZ0RGlyZWN0aW9uO1xuICAgICAgICBpZiAoTWF0aC5hYnMobmV3U2xpZGVJbmRleCkgPiBfdGhpcy5zbGlkZVBlclNpZGUpIGNvbnRpbnVlO1xuICAgICAgICBpZiAobmV3U2xpZGVJbmRleCA9PT0gMCkgY2VudGVyRGF0YUluZGV4ID0gZGF0YUluZGV4O1xuXG4gICAgICAgIHZhciBfdGhpcyRnZXRTbGlkZURPTUluZm8zID0gX3RoaXMuZ2V0U2xpZGVET01JbmZvKHNsaWRlSW5kZXgpLFxuICAgICAgICAgICAgc2xpZGVDZW50ZXJPZmZzZXQgPSBfdGhpcyRnZXRTbGlkZURPTUluZm8zLnNsaWRlQ2VudGVyT2Zmc2V0LFxuICAgICAgICAgICAgc2NhbGUgPSBfdGhpcyRnZXRTbGlkZURPTUluZm8zLnNjYWxlO1xuXG4gICAgICAgIHZhciBfdGhpcyRnZXRTbGlkZVNjYWxlQW4gPSBfdGhpcy5nZXRTbGlkZVNjYWxlQW5kT3BhY2l0eShzbGlkZUNlbnRlck9mZnNldCksXG4gICAgICAgICAgICBvcGFjaXR5ID0gX3RoaXMkZ2V0U2xpZGVTY2FsZUFuLm9wYWNpdHk7XG5cbiAgICAgICAgdmFyIF90aGlzJHNhZmVHZXRTbGlkZUluZiA9IF90aGlzLnNhZmVHZXRTbGlkZUluZm8obmV3U2xpZGVJbmRleCksXG4gICAgICAgICAgICBtYXhUcmFuc2Zvcm1EaXN0YW5jZSA9IF90aGlzJHNhZmVHZXRTbGlkZUluZi5tYXhUcmFuc2Zvcm1EaXN0YW5jZSxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gX3RoaXMkc2FmZUdldFNsaWRlSW5mLnBvc2l0aW9uO1xuXG4gICAgICAgIHN3aXBlUG9zaXRpb25JbmZvLnB1c2goe1xuICAgICAgICAgIHNsaWRlSW5kZXg6IG5ld1NsaWRlSW5kZXgsXG4gICAgICAgICAgbWF4TGVmdDogc2xpZGVDZW50ZXJPZmZzZXQgLSBwb3NpdGlvbiArIG1heFRyYW5zZm9ybURpc3RhbmNlLmxlZnQsXG4gICAgICAgICAgbWF4UmlnaHQ6IHBvc2l0aW9uICsgbWF4VHJhbnNmb3JtRGlzdGFuY2UucmlnaHQgLSBzbGlkZUNlbnRlck9mZnNldFxuICAgICAgICB9KTtcbiAgICAgICAgbmV3UmVuZGVyZWRTbGlkZXMucHVzaChfZXh0ZW5kcyh7fSwgc2xpZGUsIHtcbiAgICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgICAgb3BhY2l0eTogb3BhY2l0eSxcbiAgICAgICAgICBwb3NpdGlvbjogc2xpZGVDZW50ZXJPZmZzZXQsXG4gICAgICAgICAgc2xpZGVJbmRleDogbmV3U2xpZGVJbmRleCxcbiAgICAgICAgICB6SW5kZXg6IF90aGlzLmdldFpJbmRleChuZXdTbGlkZUluZGV4KVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvbkFjdGl2ZVNsaWRlQ2hhbmdlICYmIHNoaWZ0RGlyZWN0aW9uICE9PSAwKSB7XG4gICAgICAgIG9uQWN0aXZlU2xpZGVDaGFuZ2UoY2VudGVyRGF0YUluZGV4KTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzd2lwZVN0YXJ0ZWQ6IHRydWUsXG4gICAgICAgIGluaXRhbFN3aXBlWDogaW5pdGFsU3dpcGVYLFxuICAgICAgICByZW5kZXJlZFNsaWRlczogbmV3UmVuZGVyZWRTbGlkZXMsXG4gICAgICAgIHByZXZSZW5kZXJlZFNsaWRlczogW10uY29uY2F0KG5ld1JlbmRlcmVkU2xpZGVzKSxcbiAgICAgICAgc3dpcGVQb3NpdGlvbkluZm86IHN3aXBlUG9zaXRpb25JbmZvXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25Td2lwZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgc3dpcGVTdGFydGVkID0gX3RoaXMuc3RhdGUuc3dpcGVTdGFydGVkO1xuXG4gICAgICBpZiAoIXN3aXBlU3RhcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfdGhpcyRzdGF0ZSA9IF90aGlzLnN0YXRlLFxuICAgICAgICAgIGluaXRhbFN3aXBlWCA9IF90aGlzJHN0YXRlLmluaXRhbFN3aXBlWCxcbiAgICAgICAgICBwcmV2UmVuZGVyZWRTbGlkZXMgPSBfdGhpcyRzdGF0ZS5wcmV2UmVuZGVyZWRTbGlkZXMsXG4gICAgICAgICAgc3dpcGVQb3NpdGlvbkluZm8gPSBfdGhpcyRzdGF0ZS5zd2lwZVBvc2l0aW9uSW5mbztcbiAgICAgIHZhciBzbGlkZVdpZHRoID0gX3RoaXMucHJvcHMuc2xpZGVXaWR0aDtcbiAgICAgIHZhciB0ZW1wU2hpZnQgPSBmYWxzZTtcblxuICAgICAgdmFyIGN1cnJlbnRTd2lwZVggPSBfdGhpcy5nZXRTd2lwZVgoZSk7XG5cbiAgICAgIHZhciBzd2lwZURpc3RhbmNlID0gaW5pdGFsU3dpcGVYIC0gY3VycmVudFN3aXBlWDtcbiAgICAgIHZhciBkZWx0YSA9IE1hdGguYWJzKHN3aXBlRGlzdGFuY2UpO1xuICAgICAgdmFyIHN3aXBlTGVmdCA9IHN3aXBlRGlzdGFuY2UgPiAwO1xuICAgICAgdmFyIHRyYW5zZm9ybUZhY3RvciA9IDEwIC8gc2xpZGVXaWR0aCAqIGRlbHRhO1xuICAgICAgdmFyIHRyYW5zZm9ybVBlcmNlbnRhZ2UgPSAxIC0gTWF0aC5wb3coMSAtIChfdGhpcy5wcm9wcy5zd2lwZVNwZWVkIHx8IDAuNSksIHRyYW5zZm9ybUZhY3Rvcik7XG4gICAgICB2YXIgbmV3UmVuZGVyZWRTbGlkZXMgPSBwcmV2UmVuZGVyZWRTbGlkZXMubWFwKGZ1bmN0aW9uIChzbGlkZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gc2xpZGUucG9zaXRpb24sXG4gICAgICAgICAgICBzbGlkZUluZGV4ID0gc2xpZGUuc2xpZGVJbmRleCxcbiAgICAgICAgICAgIGRhdGFJbmRleCA9IHNsaWRlLmRhdGFJbmRleDtcbiAgICAgICAgaWYgKGRhdGFJbmRleCA9PT0gLTEpIHJldHVybiBzbGlkZTtcbiAgICAgICAgdmFyIG1heERlbHRhWCA9IHN3aXBlUG9zaXRpb25JbmZvW2luZGV4XVtzd2lwZUxlZnQgPyAnbWF4TGVmdCcgOiAnbWF4UmlnaHQnXTtcbiAgICAgICAgdmFyIHRhcmdldFBvc2l0aW9uID0gcG9zaXRpb24gKyAoc3dpcGVMZWZ0ID8gLTEgOiAxKSAqIG1heERlbHRhWCAqIHRyYW5zZm9ybVBlcmNlbnRhZ2U7XG5cbiAgICAgICAgdmFyIF90aGlzJGdldFNsaWRlU2NhbGVBbjIgPSBfdGhpcy5nZXRTbGlkZVNjYWxlQW5kT3BhY2l0eSh0YXJnZXRQb3NpdGlvbiksXG4gICAgICAgICAgICBzY2FsZSA9IF90aGlzJGdldFNsaWRlU2NhbGVBbjIuc2NhbGUsXG4gICAgICAgICAgICBvcGFjaXR5ID0gX3RoaXMkZ2V0U2xpZGVTY2FsZUFuMi5vcGFjaXR5O1xuXG4gICAgICAgIHZhciB6SW5kZXggPSBzbGlkZS56SW5kZXg7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHNsaWRlSW5kZXgpID09PSAxKSB7XG4gICAgICAgICAgaWYgKF90aGlzLmNlbnRlck9mZnNldChzbGlkZUluZGV4KSA8IF90aGlzLmNlbnRlck9mZnNldCgwKSkge1xuICAgICAgICAgICAgekluZGV4ID0gX3RoaXMubWF4WkluZGV4O1xuICAgICAgICAgICAgdGVtcFNoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHNsaWRlLCB7XG4gICAgICAgICAgcG9zaXRpb246IHRhcmdldFBvc2l0aW9uLFxuICAgICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5LFxuICAgICAgICAgIHpJbmRleDogekluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcmVuZGVyZWRTbGlkZXM6IG5ld1JlbmRlcmVkU2xpZGVzLFxuICAgICAgICB0ZW1wU2hpZnQ6IHRlbXBTaGlmdFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLnJlc2V0U2xpZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlbmRlcmVkU2xpZGVzID0gX3RoaXMuc3RhdGUucmVuZGVyZWRTbGlkZXM7XG4gICAgICB2YXIgbmV3RGVmYXVsdCA9IHJlbmRlcmVkU2xpZGVzLm1hcChmdW5jdGlvbiAoc2xpZGUpIHtcbiAgICAgICAgdmFyIF90aGlzJHNhZmVHZXRTbGlkZUluZjIgPSBfdGhpcy5zYWZlR2V0U2xpZGVJbmZvKHNsaWRlLnNsaWRlSW5kZXgpLFxuICAgICAgICAgICAgb3BhY2l0eSA9IF90aGlzJHNhZmVHZXRTbGlkZUluZjIub3BhY2l0eSxcbiAgICAgICAgICAgIHNjYWxlID0gX3RoaXMkc2FmZUdldFNsaWRlSW5mMi5zY2FsZSxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gX3RoaXMkc2FmZUdldFNsaWRlSW5mMi5wb3NpdGlvbjtcblxuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHNsaWRlLCB7XG4gICAgICAgICAgekluZGV4OiBfdGhpcy5nZXRaSW5kZXgoc2xpZGUuc2xpZGVJbmRleCksXG4gICAgICAgICAgb3BhY2l0eTogb3BhY2l0eSxcbiAgICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZW5kZXJlZFNsaWRlczogbmV3RGVmYXVsdCxcbiAgICAgICAgICBzd2lwUmlnaHQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9LCBfdGhpcy5kZWJvdW5jZWRDbGVhckludmlzaWJsZVNsaWRlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25Td2lwZUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzd2lwZVN0YXJ0ZWQgPSBfdGhpcy5zdGF0ZS5zd2lwZVN0YXJ0ZWQ7XG4gICAgICBpZiAoIXN3aXBlU3RhcnRlZCkgcmV0dXJuO1xuICAgICAgdmFyIHJlbmRlcmVkU2xpZGVzID0gX3RoaXMuc3RhdGUucmVuZGVyZWRTbGlkZXM7XG4gICAgICB2YXIgbmV3Q2VudGVyU2xpZGUgPSByZW5kZXJlZFNsaWRlcy5maW5kKGZ1bmN0aW9uIChfcmVmNykge1xuICAgICAgICB2YXIgekluZGV4ID0gX3JlZjcuekluZGV4O1xuICAgICAgICByZXR1cm4gekluZGV4ID09PSBfdGhpcy5tYXhaSW5kZXg7XG4gICAgICB9KTtcblxuICAgICAgX3RoaXMubW92ZUNhcm91c2VsKChuZXdDZW50ZXJTbGlkZSA9PT0gbnVsbCB8fCBuZXdDZW50ZXJTbGlkZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV3Q2VudGVyU2xpZGUuc2xpZGVJbmRleCkgfHwgMCk7XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdGVtcFNoaWZ0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLmdvTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLm1vdmVDYXJvdXNlbCgxKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ29CYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMubW92ZUNhcm91c2VsKC0xKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuc3dpcGVUbyA9IGZ1bmN0aW9uIChzdGVwcykge1xuICAgICAgX3RoaXMubW92ZUNhcm91c2VsKHN0ZXBzKTtcbiAgICB9O1xuXG4gICAgdmFyIF90aGlzJGluaXRpYWxpemVQcm9wZSA9IF90aGlzLmluaXRpYWxpemVQcm9wZXJ0aWVzKHRydWUpLFxuICAgICAgICByZW5kZXJlZFNsaWRlcyA9IF90aGlzJGluaXRpYWxpemVQcm9wZS5yZW5kZXJlZFNsaWRlcyxcbiAgICAgICAgc2xpZGVJbmZvTWFwID0gX3RoaXMkaW5pdGlhbGl6ZVByb3BlLnNsaWRlSW5mb01hcCxcbiAgICAgICAgc2xpZGVQZXJTaWRlID0gX3RoaXMkaW5pdGlhbGl6ZVByb3BlLnNsaWRlUGVyU2lkZSxcbiAgICAgICAgc29ydGVkU2xpZGVJbmZvID0gX3RoaXMkaW5pdGlhbGl6ZVByb3BlLnNvcnRlZFNsaWRlSW5mbyxcbiAgICAgICAgY2VudGVyUG9zaXRpb24gPSBfdGhpcyRpbml0aWFsaXplUHJvcGUuY2VudGVyUG9zaXRpb24sXG4gICAgICAgIHJlbmRlcmVkU2xpZGVQZXJTaWRlID0gX3RoaXMkaW5pdGlhbGl6ZVByb3BlLnJlbmRlcmVkU2xpZGVQZXJTaWRlO1xuXG4gICAgdmFyIG9uQWN0aXZlU2xpZGVDaGFuZ2UgPSBfdGhpcy5wcm9wcy5vbkFjdGl2ZVNsaWRlQ2hhbmdlO1xuICAgIF90aGlzLnNsaWRlSW5mb01hcCA9IHNsaWRlSW5mb01hcDtcbiAgICBfdGhpcy5zb3J0ZWRTbGlkZUluZm8gPSBzb3J0ZWRTbGlkZUluZm87XG4gICAgX3RoaXMuc2xpZGVQZXJTaWRlID0gc2xpZGVQZXJTaWRlO1xuICAgIF90aGlzLmhlaWdodCA9IF90aGlzLnByb3BzLmhlaWdodCB8fCAwO1xuICAgIF90aGlzLmxpc3RSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICBfdGhpcy5jbGVhclNsaWRlVGltZW91dCA9IG51bGw7XG4gICAgX3RoaXMua2V5Q291bnQgPSBwcm9wcy5kYXRhLmxlbmd0aDtcbiAgICBfdGhpcy5hZGRlZFNsaWRlID0gMDtcbiAgICBfdGhpcy5jZW50ZXJQb3NpdGlvbiA9IGNlbnRlclBvc2l0aW9uO1xuICAgIF90aGlzLm1heFpJbmRleCA9IDEwMDtcbiAgICBfdGhpcy5yZW5kZXJlZFNsaWRlUGVyU2lkZSA9IHJlbmRlcmVkU2xpZGVQZXJTaWRlO1xuXG4gICAgaWYgKG9uQWN0aXZlU2xpZGVDaGFuZ2UpIHtcbiAgICAgIG9uQWN0aXZlU2xpZGVDaGFuZ2UoMCk7XG4gICAgfVxuXG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBpbml0YWxTd2lwZVg6IDAsXG4gICAgICBzd2lwZVN0YXJ0ZWQ6IGZhbHNlLFxuICAgICAgcmVuZGVyZWRTbGlkZXM6IHJlbmRlcmVkU2xpZGVzLFxuICAgICAgcHJldlJlbmRlcmVkU2xpZGVzOiBbXS5jb25jYXQocmVuZGVyZWRTbGlkZXMpLFxuICAgICAgc3dpcGVQb3NpdGlvbkluZm86IFtdLFxuICAgICAgc3dpcFJpZ2h0OiBmYWxzZSxcbiAgICAgIHRlbXBTaGlmdDogZmFsc2VcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTdGFja2VkQ2Fyb3VzZWwucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMudXBkYXRlSGVpZ2h0KCk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuY2xlYXJTbGlkZVRpbWVvdXQpO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgaWYgKCFzaG91bGRSZWNhY2xjdWxhdGUodGhpcy5wcm9wcywgcHJldlByb3BzKSkgcmV0dXJuO1xuXG4gICAgdmFyIF90aGlzJGluaXRpYWxpemVQcm9wZTIgPSB0aGlzLmluaXRpYWxpemVQcm9wZXJ0aWVzKHRoaXMucHJvcHMubWF4VmlzaWJsZVNsaWRlICE9PSBwcmV2UHJvcHMubWF4VmlzaWJsZVNsaWRlKSxcbiAgICAgICAgc2xpZGVJbmZvTWFwID0gX3RoaXMkaW5pdGlhbGl6ZVByb3BlMi5zbGlkZUluZm9NYXAsXG4gICAgICAgIHNsaWRlUGVyU2lkZSA9IF90aGlzJGluaXRpYWxpemVQcm9wZTIuc2xpZGVQZXJTaWRlLFxuICAgICAgICBuZXdSZW5kZXJlZFNsaWRlcyA9IF90aGlzJGluaXRpYWxpemVQcm9wZTIubmV3UmVuZGVyZWRTbGlkZXMsXG4gICAgICAgIHNvcnRlZFNsaWRlSW5mbyA9IF90aGlzJGluaXRpYWxpemVQcm9wZTIuc29ydGVkU2xpZGVJbmZvLFxuICAgICAgICBjZW50ZXJQb3NpdGlvbiA9IF90aGlzJGluaXRpYWxpemVQcm9wZTIuY2VudGVyUG9zaXRpb247XG5cbiAgICB0aGlzLnNsaWRlSW5mb01hcCA9IHNsaWRlSW5mb01hcDtcbiAgICB0aGlzLnNvcnRlZFNsaWRlSW5mbyA9IHNvcnRlZFNsaWRlSW5mbztcbiAgICB0aGlzLnNsaWRlUGVyU2lkZSA9IHNsaWRlUGVyU2lkZTtcbiAgICB0aGlzLmNlbnRlclBvc2l0aW9uID0gY2VudGVyUG9zaXRpb247XG4gICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbml0YWxTd2lwZVg6IDAsXG4gICAgICAgIHJlbmRlcmVkU2xpZGVzOiBuZXdSZW5kZXJlZFNsaWRlcyxcbiAgICAgICAgcHJldlJlbmRlcmVkU2xpZGVzOiBbXS5jb25jYXQobmV3UmVuZGVyZWRTbGlkZXMpLFxuICAgICAgICBzd2lwUmlnaHQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH0sIHRoaXMudXBkYXRlSGVpZ2h0KTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0U3dpcGVYID0gZnVuY3Rpb24gZ2V0U3dpcGVYKGUpIHtcbiAgICBpZiAoZS50eXBlWzBdID09PSAnbScpIHJldHVybiBlLmNsaWVudFg7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIF9lJHRvdWNoZXMkLCBfZSRjaGFuZ2VkVG91Y2hlcyQ7XG5cbiAgICAgIHJldHVybiAoKF9lJHRvdWNoZXMkID0gZS50b3VjaGVzWzBdKSA9PT0gbnVsbCB8fCBfZSR0b3VjaGVzJCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UkdG91Y2hlcyQuY2xpZW50WCkgfHwgKChfZSRjaGFuZ2VkVG91Y2hlcyQgPSBlLmNoYW5nZWRUb3VjaGVzWzBdKSA9PT0gbnVsbCB8fCBfZSRjaGFuZ2VkVG91Y2hlcyQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lJGNoYW5nZWRUb3VjaGVzJC5jbGllbnRYKTtcbiAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICB0aHJvdyBFcnJvcignU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2l0aCBnZXR0aW5nIG1vdXNlIHBvc2l0aW9uJyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgX3RoaXMkc3RhdGUyID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgc3dpcGVTdGFydGVkID0gX3RoaXMkc3RhdGUyLnN3aXBlU3RhcnRlZCxcbiAgICAgICAgcmVuZGVyZWRTbGlkZXMgPSBfdGhpcyRzdGF0ZTIucmVuZGVyZWRTbGlkZXMsXG4gICAgICAgIHN3aXBSaWdodCA9IF90aGlzJHN0YXRlMi5zd2lwUmlnaHQsXG4gICAgICAgIHRlbXBTaGlmdCA9IF90aGlzJHN0YXRlMi50ZW1wU2hpZnQ7XG4gICAgdmFyIF90aGlzJHByb3BzNSA9IHRoaXMucHJvcHMsXG4gICAgICAgIENvbXBvbmVudCA9IF90aGlzJHByb3BzNS5zbGlkZUNvbXBvbmVudCxcbiAgICAgICAgX3RoaXMkcHJvcHM1JHRyYW5zaXRpID0gX3RoaXMkcHJvcHM1LnRyYW5zaXRpb25UaW1lLFxuICAgICAgICB0cmFuc2l0aW9uVGltZSA9IF90aGlzJHByb3BzNSR0cmFuc2l0aSA9PT0gdm9pZCAwID8gU3RhY2tlZENhcm91c2VsLmRlZmF1bHRUcmFuc2l0aW9uVGltZSA6IF90aGlzJHByb3BzNSR0cmFuc2l0aSxcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHM1LmNsYXNzTmFtZSxcbiAgICAgICAgZGF0YSA9IF90aGlzJHByb3BzNS5kYXRhLFxuICAgICAgICBzbGlkZVdpZHRoID0gX3RoaXMkcHJvcHM1LnNsaWRlV2lkdGgsXG4gICAgICAgIGN1c3RvbVRyYW5zaXRpb24gPSBfdGhpcyRwcm9wczUuY3VzdG9tVHJhbnNpdGlvbixcbiAgICAgICAgY2Fyb3VzZWxXaWR0aCA9IF90aGlzJHByb3BzNS5jYXJvdXNlbFdpZHRoLFxuICAgICAgICB1c2VHcmFiQ3Vyc29yID0gX3RoaXMkcHJvcHM1LnVzZUdyYWJDdXJzb3IsXG4gICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzNS5oZWlnaHQ7XG4gICAgdmFyIGN1cnNvciA9IHVzZUdyYWJDdXJzb3IgJiYgKHN3aXBlU3RhcnRlZCA/ICdncmFiYmluZycgOiAnZ3JhYicpIHx8ICdkZWZhdWx0JztcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwicmVhY3Qtc3RhY2tlZC1jZW50ZXItY2Fyb3VzZWwgXCIgKyAoY2xhc3NOYW1lIHx8ICcnKSxcbiAgICAgIG9uTW91c2VEb3duOiB0aGlzLm9uU3dpcGVTdGFydCxcbiAgICAgIG9uTW91c2VVcDogdGhpcy5vblN3aXBlRW5kLFxuICAgICAgb25Nb3VzZU1vdmU6IHRoaXMub25Td2lwZSxcbiAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5vblN3aXBlRW5kLFxuICAgICAgb25Ub3VjaFN0YXJ0OiB0aGlzLm9uU3dpcGVTdGFydCxcbiAgICAgIG9uVG91Y2hNb3ZlOiB0aGlzLm9uU3dpcGUsXG4gICAgICBvblRvdWNoRW5kOiB0aGlzLm9uU3dpcGVFbmQsXG4gICAgICByZWY6IHRoaXMubGlzdFJlZixcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHdpZHRoOiBjYXJvdXNlbFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCB8fCB0aGlzLmhlaWdodCxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgY3Vyc29yOiBjdXJzb3JcbiAgICAgIH1cbiAgICB9LCByZW5kZXJlZFNsaWRlcy5tYXAoZnVuY3Rpb24gKF9yZWY4KSB7XG4gICAgICB2YXIgb3BhY2l0eSA9IF9yZWY4Lm9wYWNpdHksXG4gICAgICAgICAgc2xpZGVJbmRleCA9IF9yZWY4LnNsaWRlSW5kZXgsXG4gICAgICAgICAgZGF0YUluZGV4ID0gX3JlZjguZGF0YUluZGV4LFxuICAgICAgICAgIHBvc2l0aW9uID0gX3JlZjgucG9zaXRpb24sXG4gICAgICAgICAgc2NhbGUgPSBfcmVmOC5zY2FsZSxcbiAgICAgICAgICBrZXkgPSBfcmVmOC5rZXksXG4gICAgICAgICAgekluZGV4ID0gX3JlZjguekluZGV4O1xuICAgICAgdmFyIElEID0gZGF0YUluZGV4ID09PSAtMSA/IFwiaGlkZGVuLVwiICsga2V5IDogc2xpZGVJbmRleDtcbiAgICAgIHZhciB6RHVyYXRpb24gPSB0cmFuc2l0aW9uVGltZSAqIChzd2lwUmlnaHQgPyAwLjYgOiAxKTtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gc3dpcGVTdGFydGVkID8gJ25vbmUnIDogY3VzdG9tVHJhbnNpdGlvbiB8fCBcImFsbCBcIiArIHRyYW5zaXRpb25UaW1lICsgXCJtcyBlYXNlLCB6LWluZGV4IFwiICsgekR1cmF0aW9uICsgXCJtcyBlYXNlXCI7XG4gICAgICB2YXIgaXNDZW50ZXJTbGlkZSA9IHRlbXBTaGlmdCA/IHpJbmRleCA9PT0gX3RoaXMyLm1heFpJbmRleCA6IHNsaWRlSW5kZXggPT09IDA7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBjbGFzc05hbWU6IFwicmVhY3Qtc3RhY2tlZC1jZW50ZXItY2Fyb3VzZWwtc2xpZGUtXCIgKyBJRCxcbiAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgbGVmdDogXCJjYWxjKDUwJSAtIFwiICsgc2xpZGVXaWR0aCAvIDIgKyBcInB4KVwiLFxuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVYKFwiICsgcG9zaXRpb24gKyBcInB4KSBzY2FsZShcIiArIHNjYWxlICsgXCIpXCIsXG4gICAgICAgICAgd2lkdGg6IHNsaWRlV2lkdGgsXG4gICAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbixcbiAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5LFxuICAgICAgICAgIHpJbmRleDogekluZGV4XG4gICAgICAgIH1cbiAgICAgIH0sIGRhdGFJbmRleCAhPT0gLTEgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHtcbiAgICAgICAgZGF0YUluZGV4OiBkYXRhSW5kZXgsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHNsaWRlSW5kZXg6IHNsaWRlSW5kZXgsXG4gICAgICAgIGlzQ2VudGVyU2xpZGU6IGlzQ2VudGVyU2xpZGUsXG4gICAgICAgIHN3aXBlVG86IF90aGlzMi5zd2lwZVRvXG4gICAgICB9KSk7XG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBTdGFja2VkQ2Fyb3VzZWw7XG59KFJlYWN0LlB1cmVDb21wb25lbnQpO1xuU3RhY2tlZENhcm91c2VsLmRlZmF1bHRTY2FsZUZhY3RvciA9IDAuODU7XG5TdGFja2VkQ2Fyb3VzZWwuZGVmYXVsdFRyYW5zaXRpb25UaW1lID0gNDUwO1xuXG5mdW5jdGlvbiBzaG91bGRSZWNhY2xjdWxhdGUocHJvcDEsIHByb3AyKSB7XG4gIHZhciBfcHJvcDEkY3VzdG9tU2NhbGVzLCBfcHJvcDIkY3VzdG9tU2NhbGVzO1xuXG4gIGlmIChwcm9wMS5zbGlkZVdpZHRoICE9PSBwcm9wMi5zbGlkZVdpZHRoIHx8IHByb3AxLmNhcm91c2VsV2lkdGggIT09IHByb3AyLmNhcm91c2VsV2lkdGggfHwgcHJvcDEubWF4VmlzaWJsZVNsaWRlICE9PSBwcm9wMi5tYXhWaXNpYmxlU2xpZGUgfHwgcHJvcDEuY3VycmVudFZpc2libGVTbGlkZSAhPT0gcHJvcDIuY3VycmVudFZpc2libGVTbGlkZSB8fCBwcm9wMS5mYWRlRGlzdGFuY2UgIT09IHByb3AyLmZhZGVEaXN0YW5jZSB8fCAoKF9wcm9wMSRjdXN0b21TY2FsZXMgPSBwcm9wMS5jdXN0b21TY2FsZXMpID09PSBudWxsIHx8IF9wcm9wMSRjdXN0b21TY2FsZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wcm9wMSRjdXN0b21TY2FsZXMuam9pbignJykpICE9PSAoKF9wcm9wMiRjdXN0b21TY2FsZXMgPSBwcm9wMi5jdXN0b21TY2FsZXMpID09PSBudWxsIHx8IF9wcm9wMiRjdXN0b21TY2FsZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wcm9wMiRjdXN0b21TY2FsZXMuam9pbignJykpKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBSZXNwb25zaXZlQ29udGFpbmVyKHByb3BzKSB7XG4gIHZhciByZW5kZXIgPSBwcm9wcy5yZW5kZXIsXG4gICAgICBjYXJvdXNlbFJlZiA9IHByb3BzLmNhcm91c2VsUmVmO1xuXG4gIHZhciBfdXNlUmVzaXplRGV0ZWN0b3IgPSB1c2VSZXNpemVEZXRlY3RvcigpLFxuICAgICAgd2lkdGggPSBfdXNlUmVzaXplRGV0ZWN0b3Iud2lkdGgsXG4gICAgICByZWYgPSBfdXNlUmVzaXplRGV0ZWN0b3IucmVmO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICByZWY6IHJlZixcbiAgICBjbGFzc05hbWU6ICdzdGFja2VkLWNhcm91c2VsLXJlc3BvbnNpdmUtY29udGFpbmVyJyxcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgIH1cbiAgfSwgd2lkdGggJiYgcmVuZGVyKHdpZHRoLCBjYXJvdXNlbFJlZikpO1xufVxuXG5leHBvcnQgeyBSZXNwb25zaXZlQ29udGFpbmVyLCBTdGFja2VkQ2Fyb3VzZWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1vZGVybi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-stacked-center-carousel@1.0.14_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-stacked-center-carousel/dist/index.modern.js\n");

/***/ })

};
;